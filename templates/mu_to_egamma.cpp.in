// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

/**
 * @file @ModelName@_mu_to_egamma.cpp
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ and SARAH @SARAHVersion@ .
 */
#include <valarray>
#include <complex>
#include <iostream>

#include "@ModelName@_mu_to_egamma.hpp"
#include "@ModelName@_mass_eigenstates.hpp"

#include "@ModelName@_cxx_diagrams.hpp"

#define INPUTPARAMETER(p) context.model.get_input().p
#define MODELPARAMETER(p) context.model.get_##p()
#define DERIVEDPARAMETER(p) context.model.p()
#define PHASE(p) context.model.get_##p()

using namespace flexiblesusy;
using namespace cxx_diagrams;

namespace {
using ChargedHiggsMultiplet = @MuEGamma_ChargedHiggsMultiplet@;
static constexpr double oneOver32PiSquared = 1.0/(32.0*Pi*Pi);

/**
 * @class MuEGammaVertexCorrectionSF
 * @brief A template that calculate contributions to the mu to e gamma
 *        of a given particle in a one loop diagram specified
 *        by a photon emitter and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *              calculate the electric dipole moment,
 *              the photon emitter and the exchange particle
 *              in a one-loop diagram where the photon emitter
 *              is a scalar and the exchange particle a fermion.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template<class EDMField1, class EDMField2, class EDMField3, class PhotonEmitter, class ExchangeParticle>
struct EDMVertexCorrectionSF {
   static std::valarray<std::complex<double>> value(
         const typename field_indices<EDMField1>::type& indices_in,
         const typename field_indices<EDMField2>::type& indices_out,
                       EvaluationContext& context);
};

/**
* @class EDMVertexCorrectionFS
* @brief A template that calculate contributions to the EDM
*        of a given particle in a one loop diagram specified
*        by a photon emitter and an exchange particle.
* @tparam Args Specifies in order the field of which to
*              calculate the electric dipole moment,
*              the photon emitter and the exchange particle
*              in a one-loop diagram where the photon emitter
*              is a fermion and the exchange particle a scalar.
*
* This template evaluates the contribution to the electric
* dipole moment of a one loop diagram with fields given by
* \a Args.
*/

template<class EDMField1, class EDMField2, class EDMField3, class PhotonEmitter, class ExchangeParticle>
struct EDMVertexCorrectionFS {
   static std::valarray<std::complex<double>> value(
         const typename field_indices<EDMField1>::type& indices_in,
         const typename field_indices<EDMField2>::type& indices_out,
                       EvaluationContext& context);
};
} // anonymous namespace

namespace flexiblesusy {
namespace @ModelName@_mu_to_egamma {
   /*
inline double sm_width(int generationIndex1,  int generationIndex2, const @ModelName@_mass_eigenstates& model ) {
   @ModelName@_mass_eigenstates model_ = model;
   EvaluationContext context{ model_ };
   std::array<int, 1> indices1 = { generationIndex1 };
   std::array<int, 1> indices2 = { generationIndex2 };

   const auto leptonInMass = context.mass<Fe>(indices1);
   const auto leptonOutMass = context.mass<Fe>(indices2);
   const auto ratio = pow(leptonOutMass/leptonInMass,2);
   const auto GF {1.1667e-5};
   const double Alpha = Sqr(Fe::electric_charge * unit_charge(context))/(4*Pi);

   return GF*GF * pow(leptonInMass,5) * (1.0 - 8.0*ratio ) * (1.0 + 0.5 * Alpha * (6.25-Sqr(Pi))/Pi)/(192.0*pow(Pi,3));
}
*/
@MuEGamma_InterfaceDefinitions@
}
} // namespace flexiblesusy

namespace {
/**
* @defgroup LoopFunctions Loop functions
* @brief The loop functions necessary for the Fe_I -> Fe_J gamma one-loop calculations.
*
* These are OneLoopFunctionA(), OneLoopFunctionB()
* as specified in arXiv:0808.1819
*/

// function from eq. 15 of hep-ph/9510309 
double OneLoopFunctionA(double r)
{
   if (is_zero(1.0-r)) {
      return 1.5;
   } else if (is_zero(r)) {
      return 2.0;
   }
   else {
      return (2.0 - 9.0*r + 18.0*r*r - 11.0*r*r*r + 6.0*r*r*r*std::log(r))/pow(1.0-r,4);
   }
}

double OneLoopFunctionB(double r)
{
   if (is_zero(1.0-r)) {
      return 1.0/12.0;
   } else if (is_zero(r)) {
      return 1.0/6.0;
   }
   else {
      return (1.0 - 6.0*r + 3.0*r*r + 2.0*r*r*r - 6.0*r*r*std::log(r))/6.0/pow(1.0-r,4);
   }
}

double OneLoopFunctionC(double r)
{
   if (is_zero(1.0-r)) {
      return 1.0/3.0;
   } else if (is_zero(r)) {
      return 1.0;
   }
   else {
      return (1.0 - r*r + 2.0*r*std::log(r))/pow(1.0-r,3);
   }
}

double OneLoopFunctionD(double r)
{
   if (is_zero(1.0-r)) {
      return -9.0/2.0;
   }
   else {
      return (16.0 - 45.0*r + 36.0*r*r - 7.0*r*r*r + 6.0*(2.0-3.0*r)*std::log(r))/pow(1.0-r,4);
   }
}

double OneLoopFunctionE(double r)
{
   if (is_zero(1.0-r)) {
      return 1.0/12.0;
   } else if (is_zero(r)) {
      return 1.0/3.0;
   }
   else {
      return (2.0 + 3.0*r - 6.0*r*r + r*r*r + 6.0*r*std::log(r))/6.0/pow(1.0-r,4);
   }
}

double OneLoopFunctionF(double r)
{
   if (is_zero(1.0-r)) {
      return 2.0/3.0;
   }
   else {
      return (-3.0 + 4.0*r - r*r - 2.0*std::log(r))/pow(1.0-r,3);
   }
}

// emit photon from the internal scalar line
template<class EDMField1, class EDMField2, class EDMField3, class PhotonEmitter, class ExchangeField>
std::valarray<std::complex<double>> EDMVertexCorrectionSF<
EDMField1, EDMField2, EDMField3, PhotonEmitter, ExchangeField
>::value(
      const typename field_indices<EDMField1>::type& indices_in, 
      const typename field_indices<EDMField2>::type& indices_out, 
      EvaluationContext& context)
{
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};

   using FermionVertexIn = Vertex<
                         EDMField1,
                         ExchangeField,
                         typename PhotonEmitter::lorentz_conjugate
                         >;
   using FermionVertexOut = Vertex<
                         typename EDMField2::lorentz_conjugate,
                         typename ExchangeField::lorentz_conjugate,
                         PhotonEmitter
                         >;
   using FermionVertexEmit = Vertex<
                         typename EDMField3::lorentz_conjugate,
                         PhotonEmitter,
                         typename PhotonEmitter::lorentz_conjugate
                         >;

   constexpr auto indexBoundsOut = FermionVertexOut::index_bounds;
   constexpr auto indexBoundsIn = FermionVertexIn::index_bounds;
   constexpr auto indexBoundsEmit = FermionVertexEmit::index_bounds;

   // loop over all possible particle "generations" attached to both vertices
   for (const auto& indexIn: indexBoundsIn) {
      for (const auto& indexOut: indexBoundsOut) {
         for (const auto& indexEmit: indexBoundsEmit) {

         // cycle if generations of external fermions  are different then requested   
         const auto edmFieldIndicesIn = FermionVertexIn::template fieldIndices<0>(indexIn);
         const auto edmFieldIndicesOut = FermionVertexOut::template fieldIndices<0>(indexOut);
         if (edmFieldIndicesIn != indices_in || edmFieldIndicesOut != indices_out)
            continue;

         // match indices of the exchange field
         const auto exchangeFieldIndicesIn = FermionVertexIn::template fieldIndices<1>(indexIn);
         const auto exchangeFieldIndicesOut = FermionVertexOut::template fieldIndices<1>(indexOut);
         if (exchangeFieldIndicesIn != exchangeFieldIndicesOut)
            continue;


         const auto photonEmitterIndicesIn = FermionVertexIn::template fieldIndices<2>(indexIn);
         const auto photonEmitterIndicesOut = FermionVertexOut::template fieldIndices<2>(indexOut);
         if ((FermionVertexEmit::template fieldIndices<1>(indexEmit)) != photonEmitterIndicesIn) {
            continue;
         }
         if ((FermionVertexEmit::template fieldIndices<2>(indexEmit)) != photonEmitterIndicesOut)
            continue;
         if ((FermionVertexEmit::template fieldIndices<1>(indexEmit)) != (FermionVertexEmit::template fieldIndices<2>(indexEmit))) continue;

         // Throw out SM Goldstone, it could crashes if SM is used.
         if ( std::is_same<PhotonEmitter, ChargedHiggsMultiplet>::type::value || 
                 std::is_same<PhotonEmitter, typename ChargedHiggsMultiplet::lorentz_conjugate>::type::value )
         {
            if ( photonEmitterIndicesIn[0] == 0 )
                continue;
         }

         const auto vertexIn = FermionVertexIn::evaluate(indexIn, context);
         const auto vertexOut = FermionVertexOut::evaluate(indexOut, context);

         const auto photonEmitterMass = context.mass<PhotonEmitter>(photonEmitterIndicesIn);
         const auto exchangeFieldMass = context.mass<ExchangeField>(exchangeFieldIndicesIn);
         const auto x = pow(exchangeFieldMass/photonEmitterMass, 2);
         const auto leptonMass = context.mass<EDMField1>(edmFieldIndicesIn);

         const double photonEmitterCharge =
            PhotonEmitter::electric_charge * unit_charge(context);

         // eq. 15 of hep-ph/9510309
         const std::complex<double> A1L =
            1./18. * vertexOut.right() * vertexIn.left() * OneLoopFunctionA(x);
         // eq. 16 of hep-ph/9510309
         const std::complex<double> A2L = 
            vertexOut.left() * vertexIn.right() * OneLoopFunctionB(x) 
            + vertexOut.left()* vertexIn.left() * exchangeFieldMass/leptonMass * OneLoopFunctionC(x);

         // eq. 15 & 16 of hep-ph/9510309 after replacement L <-> R
         const std::complex<double> A1R = 
            1./18. * vertexOut.left() * vertexIn.right() * OneLoopFunctionA(x);
         const std::complex<double> A2R = 
            vertexOut.right() * vertexIn.left() * OneLoopFunctionB(x) 
            + vertexOut.right()* vertexIn.right() * exchangeFieldMass/leptonMass * OneLoopFunctionC(x);

         const std::complex<double> massFactor = pow(photonEmitterMass,-2);

         res += oneOver32PiSquared * photonEmitterCharge * massFactor 
            * std::valarray<std::complex<double>> {A1L, A1R, A2L, A2R};
      }
   }
   }

   return res;
}

template<class Spectator>
typename field_indices<Spectator>::type
default_indices_for_spectator( void );

template<>
typename field_indices<VP>::type
default_indices_for_spectator<VP>( void )
{
  return {};
}

template<>
typename field_indices<VG>::type
default_indices_for_spectator<VG>( void )
{
  return {0};
}

// emit photon from the internal fermion line
template<class EDMField1, class EDMField2, class EDMField3, class PhotonEmitter, class ExchangeField>
std::valarray<std::complex<double>> EDMVertexCorrectionFS<
EDMField1, EDMField2, EDMField3, PhotonEmitter, ExchangeField
>::value(const typename field_indices<EDMField1>::type& indices_in, 
      const typename field_indices<EDMField2>::type& indices_out,
      EvaluationContext& context)
{
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};

   using FermionVertexIn = Vertex<
                         EDMField1,
                         ExchangeField,
                         typename PhotonEmitter::lorentz_conjugate
                         >;
   using FermionVertexOut = Vertex<
                         typename EDMField2::lorentz_conjugate,
                         typename ExchangeField::lorentz_conjugate,
                         PhotonEmitter
                         >;
   using FermionVertexEmit = Vertex<
                         typename EDMField3::lorentz_conjugate,
                         PhotonEmitter,
                         typename PhotonEmitter::lorentz_conjugate
                         >;
   
   constexpr auto indexBoundsOut = FermionVertexOut::index_bounds;
   constexpr auto indexBoundsIn = FermionVertexIn::index_bounds;

   // loop over all possible particle "generations" attached to both vertices
   for (const auto& indexIn: indexBoundsIn) {
      for (const auto& indexOut: indexBoundsOut) {

         // cycle if generations of external fermions are different then requested   
         const auto edmFieldIndicesIn = FermionVertexIn::template fieldIndices<0>(indexIn);
         const auto edmFieldIndicesOut = FermionVertexOut::template fieldIndices<0>(indexOut);
         if (edmFieldIndicesIn != indices_in || edmFieldIndicesOut != indices_out)
            continue;

         // match indices of the exchange field
         const auto exchangeFieldIndicesIn = FermionVertexIn::template fieldIndices<1>(indexIn);
         const auto exchangeFieldIndicesOut = FermionVertexOut::template fieldIndices<1>(indexOut);
         if (exchangeFieldIndicesIn != exchangeFieldIndicesOut )
            continue;

         const auto photonEmitterIndicesIn = FermionVertexIn::template fieldIndices<2>(indexIn);
         const auto photonEmitterIndicesOut = FermionVertexOut::template fieldIndices<2>(indexOut);
         if (photonEmitterIndicesIn != photonEmitterIndicesOut) continue;

         // Throw out SM Goldstone, it could crash if SM is used.
         if ( std::is_same<ExchangeField, ChargedHiggsMultiplet>::type::value || 
                 std::is_same<ExchangeField, typename ChargedHiggsMultiplet::lorentz_conjugate>::type::value )
         {
            if ( exchangeFieldIndicesIn[0] == 0 )
                continue;
         }

         const auto vertexIn = FermionVertexIn::evaluate(indexIn, context);
         const auto vertexOut = FermionVertexOut::evaluate(indexOut, context);
         auto vertexEmit = vertexIn; 
         
auto spectator_indices = default_indices_for_spectator<EDMField3>();

const auto a = flexiblesusy::cxx_diagrams::impl::concatenate( flexiblesusy::cxx_diagrams::impl::concatenate( spectator_indices, photonEmitterIndicesIn ), photonEmitterIndicesIn );

FermionVertexEmit::evaluate(a, context);

         const auto photonEmitterMass = context.mass<PhotonEmitter>(photonEmitterIndicesIn);
         const auto exchangeFieldMass = context.mass<ExchangeField>(exchangeFieldIndicesIn);
         const auto x = pow(photonEmitterMass/exchangeFieldMass, 2);
         const auto leptonMass = context.mass<EDMField1>(edmFieldIndicesIn);

         const double photonEmitterCharge =
            PhotonEmitter::electric_charge * unit_charge(context);

         // eq. 18 of hep-ph/9510309
         const std::complex<double> A1L =
            1./18. * vertexOut.right() * vertexIn.left() * OneLoopFunctionD(x);
         // eq. 19 of hep-ph/9510309
         const std::complex<double> A2L = 
            vertexOut.left() * vertexIn.right() * OneLoopFunctionE(x) 
            + vertexOut.left()* vertexIn.left() * photonEmitterMass/leptonMass * OneLoopFunctionF(x);

         // eq. 18 & 18 of hep-ph/9510309 after replacement L <-> R
         const std::complex<double> A1R = 
            1./18. * vertexOut.left() * vertexIn.right() * OneLoopFunctionD(x);
         const std::complex<double> A2R = 
            vertexOut.right() * vertexIn.left() * OneLoopFunctionE(x) 
            + vertexOut.right()* vertexIn.right() * photonEmitterMass/leptonMass * OneLoopFunctionF(x);
         const std::complex<double> massFactor = pow(exchangeFieldMass,-2);

         res -= oneOver32PiSquared * photonEmitterCharge * massFactor 
            * std::valarray<std::complex<double>> {A1L, A1R, A2L, A2R};
      }
   }

   return res;
}

} // anonymous namespace
