// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#ifndef @ModelName@_SPECTRUM_GENERATOR_H
#define @ModelName@_SPECTRUM_GENERATOR_H

#include "@ModelName@_spectrum_generator_interface.hpp"
#include "@ModelName@_two_scale_high_scale_constraint.hpp"
#include "@ModelName@_two_scale_susy_scale_constraint.hpp"
#include "SM_two_scale_low_scale_constraint.hpp"
#include "@ModelName@_two_scale_convergence_tester.hpp"
#include "@ModelName@_SM_two_scale_initial_guesser.hpp"
#include "@ModelName@_utilities.hpp"
#include "@ModelName@_SM_matching.hpp"
#include "@ModelName@_input_parameters.hpp"
#include "@ModelName@_SM_two_scale_matching.hpp"

#include "lowe.h"
#include "error.hpp"
#include "numerics2.hpp"
#include "two_scale_running_precision.hpp"
#include "two_scale_solver.hpp"
#include "SM_two_scale_model.hpp"
#include "ew_input.hpp"

#include <limits>

namespace flexiblesusy {
using namespace softsusy;

#define MODELPARAMETER(p) model.get_##p()

template <class T>
class @ModelName@_SM_spectrum_generator
   : public @ModelName@_spectrum_generator_interface<T> {
public:
   @ModelName@_SM_spectrum_generator()
      : @ModelName@_spectrum_generator_interface<T>()
      , solver()
      , high_scale_constraint()
      , susy_scale_constraint()
      , low_scale_constraint()
      , high_scale(0.)
      , susy_scale(0.)
      , low_scale(0.)
   {}
   virtual ~@ModelName@_SM_spectrum_generator() {}

   const SM<T>& get_eft() const { return eft; }
   double get_high_scale() const { return high_scale; }
   double get_susy_scale() const { return susy_scale; }
   double get_low_scale()  const { return low_scale;  }
   virtual void run(const softsusy::QedQcd&, const @ModelName@_input_parameters&);
   void write_running_couplings(const std::string& filename = "@ModelName@_rgflow.dat") const;

private:
   SM<T> eft;
   RGFlow<T> solver;
   @ModelName@_high_scale_constraint<T> high_scale_constraint;
   @ModelName@_susy_scale_constraint<T> susy_scale_constraint;
   SM_low_scale_constraint<T>  low_scale_constraint;
   @ModelName@_SM_Matching<T> matching;

   double high_scale, susy_scale, low_scale;
};

/**
 * @brief Run's the RG solver with the given input parameters
 *
 * This function sets up the RG solver using a high-scale, susy-scale
 * and low-scale constraint.  Afterwards the solver is run until
 * convergence is reached or an error occours.  Finally the particle
 * spectrum (pole masses) is calculated.
 *
 * @param oneset Standard Model input parameters
 * @param input model input parameters
 */
template <class T>
void @ModelName@_SM_spectrum_generator<T>::run(const softsusy::QedQcd& oneset,
                                const @ModelName@_input_parameters& input)
{
   @ModelName@<T>& model = this->model;
   model.clear();
   model.set_input_parameters(input);
   model.do_calculate_sm_pole_masses(this->calculate_sm_masses);
   model.do_force_output(this->force_output);
   model.set_loops(this->beta_loop_order);
   model.set_thresholds(this->threshold_corrections_loop_order);
   model.set_zero_threshold(this->beta_zero_threshold);

   eft.clear();
   eft.do_force_output(this->force_output);
   eft.set_loops(this->beta_loop_order);
   eft.set_thresholds(this->threshold_corrections_loop_order);
   eft.set_zero_threshold(this->beta_zero_threshold);
   eft.set_pole_mass_loop_order(this->model.get_pole_mass_loop_order());
   eft.set_ewsb_loop_order(this->model.get_ewsb_loop_order());
   eft.set_ewsb_iteration_precision(this->model.get_ewsb_iteration_precision());
   eft.set_number_of_ewsb_iterations(this->model.get_number_of_ewsb_iterations());
   eft.set_number_of_mass_iterations(this->model.get_number_of_mass_iterations());

   high_scale_constraint.clear();
   susy_scale_constraint.clear();
   low_scale_constraint .clear();

   // needed for constraint::initialize()
   high_scale_constraint.set_model(&model);
   susy_scale_constraint.set_model(&model);
   low_scale_constraint .set_model(&eft);

   low_scale_constraint .set_sm_parameters(oneset);
   matching.set_models(&eft, &model);
   matching.set_constraint(&susy_scale_constraint);

   high_scale_constraint.initialize();
   susy_scale_constraint.initialize();
   low_scale_constraint .initialize();

   std::vector<Constraint<T>*> model_constraints(2);
   model_constraints[0] = &low_scale_constraint;
   model_constraints[1] = &high_scale_constraint;

   std::vector<Constraint<T>*> eft_constraints(1);
   eft_constraints[0] = &low_scale_constraint;

   @ModelName@_convergence_tester<T> convergence_tester(&model, this->precision_goal);
   if (this->max_iterations > 0)
      convergence_tester.set_max_iterations(this->max_iterations);

   @ModelName@_SM_initial_guesser<T> initial_guesser(&model, &eft, oneset,
                                                  low_scale_constraint,
                                                  susy_scale_constraint,
                                                  high_scale_constraint);

   Two_scale_increasing_precision precision(10.0, this->precision_goal);

   solver.reset();
   solver.set_convergence_tester(&convergence_tester);
   solver.set_running_precision(&precision);
   solver.set_initial_guesser(&initial_guesser);
   solver.add_model(&eft, &matching, eft_constraints);
   solver.add_model(&model, model_constraints);

   high_scale = susy_scale = low_scale = 0.;
   this->reached_precision = std::numeric_limits<double>::infinity();

   try {
      solver.solve();
      high_scale = high_scale_constraint.get_scale();
      susy_scale = susy_scale_constraint.get_scale();
      low_scale  = low_scale_constraint.get_scale();
      this->reached_precision = convergence_tester.get_current_accuracy();

      model.run_to(susy_scale);
      model.solve_ewsb();
      model.calculate_spectrum();

      // start logarithmic resummation
      if (model.get_two_loop_corrections().higgs_log)
      {
         model.run_to(susy_scale);
         matching.match_high_to_low_scale_model();
         eft.run_to(low_scale);
         low_scale_constraint.apply();

         double const Mt = low_scale_constraint.get_sm_parameters().displayPoleMt(); 
         if(susy_scale > Mt) 
         {
            eft.run_to(Mt);
         } 
         else 
         {
            eft.run_to(susy_scale);
         }

         eft.calculate_DRbar_masses();
         eft.solve_ewsb();
         // eft.calculate_spectrum();  
         // does not work properly, find out why!

         eft.calculate_MVWp_pole();
         eft.calculate_MVZ_pole();
         eft.calculate_MFu_pole();
         eft.calculate_MFd_pole();
         eft.calculate_MFe_pole();

         // since Higgs mass matching is locked to 1-loop, so is this calculation
         eft.set_pole_mass_loop_order(1);
         eft.solve_ewsb_one_loop();
         eft.calculate_Mhh_pole();

         this->model.get_physical().M@HiggsBoson_0@ = eft.get_physical().Mhh;
         this->model.get_physical().M@VectorZ_0@ = eft.get_physical().MVZ;
         this->model.get_physical().M@VectorW_0@ = eft.get_physical().MVWp;
         this->model.get_physical().M@TopQuark@ = eft.get_physical().MFu;
         this->model.get_physical().M@BottomQuark@ = eft.get_physical().MFd;
         this->model.get_physical().M@Electron@ = eft.get_physical().MFe;
      }
      
      // copy calculated W pole mass
      model.get_physical().M@VectorW@
         = low_scale_constraint.get_sm_parameters().displayPoleMW();

      // run to output scale (if scale > 0)
      if (!is_zero(this->parameter_output_scale)) {
         model.run_to(this->parameter_output_scale);
         eft.run_to(this->parameter_output_scale);
      }
   } catch (const NoConvergenceError&) {
      model.get_problems().flag_no_convergence();
   } catch (const NonPerturbativeRunningError&) {
      model.get_problems().flag_no_perturbative();
   } catch (const NoRhoConvergenceError&) {
      model.get_problems().flag_no_rho_convergence();
   } catch (const Error& error) {
      model.get_problems().flag_thrown(error.what());
   } catch (const std::string& str) {
      model.get_problems().flag_thrown(str);
   } catch (const char* str) {
      model.get_problems().flag_thrown(str);
   } catch (const std::exception& error) {
      model.get_problems().flag_thrown(error.what());
   }
}

/**
 * Create a text file which contains the values of all model
 * parameters at all scales between the low-scale and the high-scale.
 *
 * @param filename name of output file
 */
template <class T>
void @ModelName@_SM_spectrum_generator<T>::write_running_couplings(
   const std::string& filename) const
{
   @ModelName@_spectrum_generator_interface<T>::write_running_couplings(filename, low_scale, high_scale);
}


} // namespace flexiblesusy

#endif
