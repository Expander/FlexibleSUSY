(* ::Package:: *)

(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

(* There is a problem with Global`args which comes from mathematica paclets.*)
Quiet[Needs["FeynArts`"],{FeynArts`args::shdw}];
(* Change this to 2 to see more output (if 1 then less). *)
FeynArts`$FAVerbose = 0;

Needs["FormCalc`"];
(* Change this to 1,2 or 3 to see more output. *)
FormCalc`$FCVerbose = 0;

(* Next Format makes some pattern generate mistakes. *)
Format[FormCalc`DiracChain[FormCalc`Private`s1_FormCalc`Spinor,FormCalc`Private`om_,FormCalc`Private`g___,FormCalc`Private`s2_FormCalc`Spinor]] =.;
Needs["Utils`"];

BeginPackage["NPointFunctions`"];

{SetInitialValues,NPointFunctionFAFC}

Off[General::shdw]
{
   LorentzIndex,GenericSum,GenericIndex,
   GenericS,GenericF,GenericV,GenericU,
   LoopLevel,Regularize,ZeroExternalMomenta,OnShellFlag,KeepProcesses,


   DimensionalReduction,DimensionalRegularization,OperatorsOnly,
   (*for further details inspect topologyReplacements*)
   Irreducible,Triangles,FourFermionScalarPenguins,
   FourFermionMassiveVectorPenguins,FourFermionFlavourChangingBoxes
} ~ SetAttributes ~ {Locked,Protected};
On[General::shdw]

Begin["`internal`"];

`type`vertex = FeynArts`Vertex[_Integer][_Integer];
`type`propagator = FeynArts`Propagator[ FeynArts`External|FeynArts`Incoming|FeynArts`Outgoing|FeynArts`Internal|FeynArts`Loop[_Integer] ][`type`vertex,`type`vertex,Repeated[FeynArts`Field[_Integer],{0,1}]];
`type`topology = FeynArts`Topology[_Integer][`type`propagator..];
`type`diagramSet = FeynArts`TopologyList[_][Rule[`type`topology,FeynArts`Insertions[Generic][__]]..];
`type`nullableDiagramSet = FeynArts`TopologyList[_][Rule[`type`topology,FeynArts`Insertions[Generic][___]]...];

`type`indexCol =
   FeynArts`Index[Global`Colour,_Integer];

`type`indexGlu =
   FeynArts`Index[Global`Gluon,_Integer];

`type`indexGeneric =
   FeynArts`Index[Generic, _Integer];
indexGeneric[index:_Integer] :=
   FeynArts`Index[Generic, index];
indexGeneric // Utils`MakeUnknownInputDefinition;
indexGeneric ~ SetAttributes ~ {Protected,Locked};

`type`fieldFA = FeynArts`S|FeynArts`F|FeynArts`V|FeynArts`U;

(*sec 6.1 of manual*)
`type`amplitude = FeynArts`FeynAmp[
   FeynArts`GraphID[FeynArts`Topology==_Integer,Generic==_Integer],(*name of the amplitude*)
   Integral[FeynArts`FourMomentum[FeynArts`Internal,_Integer]],(*momentum of integration*)
   _,(*generic analytic expression of the amplitude*)
   {__}->FeynArts`Insertions[FeynArts`Classes][{__}..](*replacement rules to obtain the class level*)
];

`type`FAfieldGeneric = `type`fieldFA[`type`indexGeneric];

getProcess[diagrams:`type`diagramSet] := Cases[Head@diagrams, (FeynArts`Process->x_) :> x][[1]];
getProcess // Utils`MakeUnknownInputDefinition;
getProcess ~ SetAttributes ~ {Protected,Locked};

getField[diagrams:`type`diagramSet,number:_Integer] :=
   Cases[diagrams[[1,2,1,2,1]],Rule[FeynArts`Field@number,x_] :> x][[1]] /;
   0<number<=Plus@@(Length/@getProcess@diagrams);
getField // Utils`MakeUnknownInputDefinition;
getField ~ SetAttributes ~ {Protected,Locked};

`type`amplitudeSet = FeynArts`FeynAmpList[__][`type`amplitude..];

`type`pickTopoAmp = {Rule[True | False,{__Integer}]..};
`type`saveAmpClass = {Rule[_Integer,{__Integer} | All]..};

particleNamesFile = "";
substitutionsFile = "";
particleNamespaceFile = "";

subexpressionToFSRules::usage=
"A set of rules that aid translation between FeynArts and FlexibleSUSY language.
They should be applied to subexpressions generated by FeynArts.";
subexpressionToFSRules = {};

fieldNameToFSRules::usage=
"A set of rules for @todo";
fieldNameToFSRules = {};

amplitudeToFSRules::usage=
"A set of rules for @todo";
amplitudeToFSRules= {};

Protect[particleNamesFile,substitutionsFile,particleNamespaceFile,
   subexpressionToFSRules,fieldNameToFSRules,amplitudeToFSRules
];

SetInitialValues::usage=
"@brief Set the FeynArts and FormCalc paths, creates required directories.
@param FCDirS the directory designated for FormCalc output
@param FAModelS the name of the FeynArts model file
@param particleNamesFileS the name of the SARAH-generated particle names file
@param substitutionsFileS the name of the SARAH-generated substitutions file
@param particleNamespaceFileS the name of the particle namespace file
@note Allowed to be called only once";
SetInitialValues::errOnce=
"Paths for FeynArts and FormCalc have been defined already.";
SetInitialValues[FCDir_String, FAModel_String,
   particleNamesFileS_String, substitutionsFileS_String,
   particleNamespaceFileS_String] :=
Module[{},
   If[!DirectoryQ@FCDir,CreateDirectory@FCDir];
   SetDirectory@FCDir;

   FeynArts`InitializeModel@FAModel;
   SetOptions[FeynArts`InsertFields,FeynArts`Model->FAModel,FeynArts`InsertionLevel->FeynArts`Classes];

   (*Which index types do we load with the model?*)
   `type`indexGen = FeynArts`Index[Alternatives@@Cases[MakeBoxes@Definition@FeynArts`IndexRange,RowBox@{"Index","[",name:Except["Colour"|"Gluon"],"]"}:>ToExpression["Global`"<>name],Infinity],_Integer];

   (* Define type of masses *)
   genericMass::usage="
   @note In FeynArts 3.11 the pattern for a generic mass was changed and now
         contains Loop and Internal as well.";
   With[{new=Repeated[Alternatives[FeynArts`Loop, FeynArts`Internal], {0, 1}]},
      `type`genericMass =
         FeynArts`Mass[`type`fieldFA[`type`indexGeneric], new];
      genericMass[field:`type`fieldFA, index:_Integer] :=
         FeynArts`Mass[field@indexGeneric@index, new];
      genericMass[field:`type`fieldFA] :=
         FeynArts`Mass[field[`type`indexGeneric], new];
      genericMass // Utils`MakeUnknownInputDefinition;
      genericMass ~ SetAttributes ~ {Protected,Locked};
   ];

   `type`specificMass =
      FeynArts`Mass[`type`fieldFA[_Integer, {Alternatives[`type`indexCol, `type`indexGlu, `type`indexGen]..}]];

   {particleNamesFile,substitutionsFile,particleNamespaceFile}~ClearAttributes~{Protected};
   particleNamesFile = particleNamesFileS;
   substitutionsFile = substitutionsFileS;
   particleNamespaceFile = particleNamespaceFileS;
   {particleNamesFile,substitutionsFile,particleNamespaceFile}~SetAttributes~{Protected, Locked};

   SetFSConventionRules[];
] /; Utils`AssertOrQuit[
   And@@(TrueQ[#=={Protected}] &/@ Attributes@{particleNamesFile,substitutionsFile,particleNamespaceFile}),
   SetInitialValues::errOnce];
SetInitialValues // Utils`MakeUnknownInputDefinition;
SetInitialValues ~ SetAttributes ~ {Protected,Locked};

SetFSConventionRules::usage=
"@brief Set the translation rules from FeynArts/FormCalc to FlexibleSUSY
language.";
SetFSConventionRules[] :=
Module[
   {
      pairSumIndex=Unique@"SARAH`lt",
      fieldNames,indexRules,massRules,couplingRules,generalFCRules,
      sumOverRules
   },
   fieldNames =
   Flatten[
      StringCases[
         Utils`ReadLinesInFile@particleNamesFile,
         x__ ~~ ": " ~~ y:"S"|"V"|"U"|"F" ~~ "[" ~~ int__ ~~ "]" ~~ ___ :> {x,y,int}],
      1] /.
      Apply[Rule, {#[[1]], #[[2]] <> #[[1]]} &/@ Get@particleNamespaceFile, 2];
   massRules = Append[Flatten[Module[
      {P="SARAH`Mass@"<>#,MassP=StringReplace[#,__~~"`"->"Global`Mass"]},
      {
         ToExpression[MassP <> "@indices_:>" <> P <>
         "@{Symbol[\"SARAH`gt\"<>StringTake[SymbolName@indices,-1]]}"],
         ToExpression[MassP <> "@indices__:>" <> P <> "@{indices}"],
         ToExpression[MassP <> "->" <> P]
      }
      ] &/@ fieldNames[[All, 1]] ],
      FeynArts`Mass[field_, _ : Null] :> SARAH`Mass[field]
   ];

   couplingRules =
   {
      FeynArts`G[_][0][fields__][1] :>
      SARAH`Cp[fields][1],

      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`ChiralityProjector[-1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PL],

      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`ChiralityProjector[1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PR],

      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`DiracMatrix@FeynArts`KI1@3,
            Global`ChiralityProjector[-1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PL],

      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`DiracMatrix@FeynArts`KI1@3,
            Global`ChiralityProjector[1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PR],

      FeynArts`G[_][0][fields__][ Global`MetricTensor[FeynArts`KI1[i1_Integer],FeynArts`KI1[i2_Integer]] ] :>
      SARAH`Cp[fields][SARAH`g[ LorentzIndex[{fields}[[i1]]],LorentzIndex[{fields}[[i2]]]] ],

      FeynArts`G[_][0][fields__][
         FeynArts`Mom[ i1_Integer ] - FeynArts`Mom[ i2_Integer ]
      ] :>
      SARAH`Cp[fields][
         SARAH`Mom[ {fields}[[i1]] ] - SARAH`Mom[ {fields}[[i2]] ]
      ],

      (*Since FormCalc-9.7*)
      FeynArts`G[_][0][fields__][
         Global`FourVector[
            FeynArts`Mom[ i1_Integer ] - FeynArts`Mom[ i2_Integer ],
            FeynArts`KI1[3]
         ]
      ] :>
      SARAH`Cp[fields][
         SARAH`Mom[ {fields}[[i1]] ] - SARAH`Mom[ {fields}[[i2]] ]
      ],

      (*VVV couplings*)
      FeynArts`G[_][0][fields__][
         (-FeynArts`Mom[i1_Integer] + FeynArts`Mom[i2_Integer])*
         Global`MetricTensor[FeynArts`KI1[i1_Integer],FeynArts`KI1[i2_Integer]]
         +
         (+FeynArts`Mom[i1_Integer] - FeynArts`Mom[i3_Integer])*
         Global`MetricTensor[FeynArts`KI1[i1_Integer],FeynArts`KI1[i3_Integer]]
         +
         (-FeynArts`Mom[i2_Integer] + FeynArts`Mom[i3_Integer])*
         Global`MetricTensor[FeynArts`KI1[i2_Integer],FeynArts`KI1[i3_Integer]]
      ] :>
      SARAH`Cp[fields][
         (SARAH`Mom[{fields}[[i2]], LorentzIndex[{fields}[[i3]]]] -
         SARAH`Mom[{fields}[[i1]], LorentzIndex[{fields}[[i3]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i1]] ],LorentzIndex[ {fields}[[i2]] ] ]
         ,
         (SARAH`Mom[{fields}[[i1]], LorentzIndex[{fields}[[i2]]]] -
         SARAH`Mom[{fields}[[i3]], LorentzIndex[{fields}[[i2]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i1]] ],LorentzIndex[ {fields}[[i3]] ] ]
         ,
         (SARAH`Mom[{fields}[[i3]], LorentzIndex[{fields}[[i1]]]] -
         SARAH`Mom[{fields}[[i2]], LorentzIndex[{fields}[[i1]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i2]] ],LorentzIndex[ {fields}[[i3]] ] ]
      ],

      (* Since FormCalc-9.7 *)
      FeynArts`G[_][0][fields__][
         Global`FourVector[-FeynArts`Mom[i1_Integer] + FeynArts`Mom[i2_Integer], FeynArts`KI1[i3_Integer]]*
         Global`MetricTensor[FeynArts`KI1[i1_Integer], FeynArts`KI1[i2_Integer]]
         +
         Global`FourVector[+FeynArts`Mom[i1_Integer] - FeynArts`Mom[i3_Integer], FeynArts`KI1[i2_Integer]]*
         Global`MetricTensor[FeynArts`KI1[i1_Integer], FeynArts`KI1[i3_Integer]]
         +
         Global`FourVector[-FeynArts`Mom[i2_Integer] + FeynArts`Mom[i3_Integer], FeynArts`KI1[i1_Integer]]*
         Global`MetricTensor[FeynArts`KI1[i2_Integer], FeynArts`KI1[i3_Integer]]
      ] :>
      SARAH`Cp[fields][
         (SARAH`Mom[{fields}[[i2]], LorentzIndex[{fields}[[i3]]]] -
         SARAH`Mom[{fields}[[i1]], LorentzIndex[{fields}[[i3]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i1]] ],LorentzIndex[ {fields}[[i2]] ] ]
         ,
         (SARAH`Mom[{fields}[[i1]], LorentzIndex[{fields}[[i2]]]] -
         SARAH`Mom[{fields}[[i3]], LorentzIndex[{fields}[[i2]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i1]] ],LorentzIndex[ {fields}[[i3]] ] ]
         ,
         (SARAH`Mom[{fields}[[i3]], LorentzIndex[{fields}[[i1]]]] -
         SARAH`Mom[{fields}[[i2]], LorentzIndex[{fields}[[i1]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i2]] ],LorentzIndex[ {fields}[[i3]] ] ]
      ]
   };

   (* @note Sec 4.4 of FormCalc manual *)
   generalFCRules =
   {
      FormCalc`Finite -> 1,
      FormCalc`Den[a_,b_] :> 1/(a-b),
      FormCalc`Pair[a_,b_] :> SARAH`sum[
         pairSumIndex,1,4,
         SARAH`g[pairSumIndex,pairSumIndex]*Append[a,pairSumIndex]*Append[b,pairSumIndex]],
      fieldType_?(FAFieldQ)[FeynArts`Index[Generic,number_Integer]] :> fieldType@GenericIndex@number,
      FormCalc`k[i_Integer,indexInPair___] :> SARAH`Mom[i,indexInPair]
   };

   indexRules =                                                                 (* @note These index rules are specific to SARAH generated FeynArts model files.*)
   {
      index:`type`indexGen :> Symbol["SARAH`gt" <> ToString@Last@index],
      index:`type`indexCol :> Symbol["SARAH`ct" <> ToString@Last@index],
      index:`type`indexGlu :> (Print["Warning: check indexRules of internal.m"];Symbol["SARAH`ct" <> ToString@Last@index])
   };

   sumOverRules =
   {
      FeynArts`SumOver[_,_,FeynArts`External] :> Sequence[],
      Times[expr_,FeynArts`SumOver[index_,max_Integer]] :>
         SARAH`sum[index,1,max,expr],
      Times[expr_,FeynArts`SumOver[index_,{min_Integer,max_Integer}]] :>
         SARAH`sum[index,min,max,expr],
      SARAH`sum[index_,_Integer,max_Integer,FeynArts`SumOver[_,max2_Integer]] :>            (* @todo check these weird convention rules *)
         SARAH`sum[index,1,max,max2],                                                       (* *)
      SARAH`sum[index_,_Integer,max_Integer,FeynArts`SumOver[_,{min2_Integer,max2_Integer}]](* *)
    :> SARAH`sum[index,1,max,max2-min2]                                                     (* *)
};

   Unprotect@fieldNameToFSRules;
   fieldNameToFSRules = Join[
      Map[ToExpression,fieldNames,2] /. {name_,type_,number_}:>Rule[type@number,name],
      Map[ToExpression,fieldNames,2] /. {name_,type_,number_}:>RuleDelayed[type[number,{indices__}],name@{indices}],
      Map[ToExpression,fieldNames,2] /.
      {
         {name_,type:FeynArts`S|FeynArts`V,_}:>RuleDelayed[Times[-1,field:name],Susyno`LieGroups`conj@name],
         {name_,type:FeynArts`U|FeynArts`F,_}:>RuleDelayed[Times[-1,field:name],SARAH`bar@name]
      },
      Map[ToExpression,fieldNames,2] /.
      {
         {name_,type:FeynArts`S|FeynArts`V,_}:>RuleDelayed[Times[-1,field:name@{indices__}],Susyno`LieGroups`conj@name@{indices}],
         {name_,type:FeynArts`U|FeynArts`F,_}:>RuleDelayed[Times[-1,field:name@{indices__}],SARAH`bar@name@{indices}]
      },
      indexRules,
      {FeynArts`S->GenericS,FeynArts`F->GenericF,FeynArts`V->GenericV,FeynArts`U->GenericU},
      {
         Times[-1,field:_GenericS|_GenericV]:>Susyno`LieGroups`conj@field,
         Times[-1,field:_GenericF|_GenericU]:>SARAH`bar@field
      }
   ];
   Protect@fieldNameToFSRules;

   Unprotect@subexpressionToFSRules;
   subexpressionToFSRules = Join[
      massRules,
      fieldNameToFSRules,
      couplingRules,
      generalFCRules
   ];
   Protect@subexpressionToFSRules;

   Unprotect@amplitudeToFSRules;
   amplitudeToFSRules = Join[
      subexpressionToFSRules,
      sumOverRules,
      {FeynArts`IndexSum -> Sum}
   ];
   Protect@amplitudeToFSRules;
];
SetFSConventionRules // Utils`MakeUnknownInputDefinition;
SetFSConventionRules ~ SetAttributes ~ {Protected,Locked};

Options[NPointFunctionFAFC]={
   LoopLevel -> 1,
   Regularize -> DimensionalReduction,
   ZeroExternalMomenta -> True,
   OnShellFlag -> False,
   KeepProcesses -> {}
};
NPointFunctionFAFC::usage=
"@todo";
NPointFunctionFAFC[inFields_,outFields_,OptionsPattern[]] :=
Module[
   {
      settingsForGenericSums,settingsForMomElim,
      topologies, diagrams, amplitudes, genericInsertions, colourFactors,
      fsFields, fsInFields, fsOutFields, externalMomentumRules, nPointFunction
   },
   topologies = FeynArts`CreateTopologies[
      OptionValue@LoopLevel,
      Length@inFields -> Length@outFields,
      FeynArts`ExcludeTopologies -> getExcludedTopologies@OptionValue@KeepProcesses
   ];
   If[List@@topologies === {},Return@`subkernel`error@`subkernel`message::errNoTopologies];
   diagrams = FeynArts`InsertFields[topologies,inFields->outFields];
   If[List@@diagrams === {},Return@`subkernel`error@`subkernel`message::errNoDiagrams];

   diagrams = getModifiedDiagrams[diagrams,OptionValue@KeepProcesses];
   If[List@@diagrams === {},Return@`subkernel`error@`subkernel`message::errNoDiagrams];

   amplitudes = FeynArts`CreateFeynAmp@diagrams;
   amplitudes = Delete[amplitudes,Position[amplitudes,FeynArts`Index[Global`Colour,_Integer]]];(* @note Remove colour indices following assumption 1. *)
   {diagrams,amplitudes} = getModifiedDA[{diagrams,amplitudes},OptionValue@KeepProcesses];

   settingsForGenericSums = getRestrictionsOnGenericSumsByTopology@diagrams;
   settingsForMomElim = getMomElimForAmplitudesByTopology@diagrams;

   genericInsertions = Map[Last,#,{3}] &@ Flatten[                              (* Everything is sorted already, so we need only field-replacement names *)
      GenericInsertionsForDiagram /@ (List @@ diagrams), 1];

   colourFactors = Flatten[
      ColourFactorForDiagram /@ (List @@ diagrams), 1] //.
      fieldNameToFSRules;

   fsInFields = Head[amplitudes][[1,2,1,All,1]] //. fieldNameToFSRules;
   fsOutFields = Head[amplitudes][[1,2,2,All,1]] //. fieldNameToFSRules;

   fsFields = Join[fsInFields,fsOutFields];
   externalMomentumRules = Switch[OptionValue@ZeroExternalMomenta,
      True, {SARAH`Mom[_Integer,_] :> 0},
      False|OperatorsOnly, {SARAH`Mom[i_Integer, lorIndex_] :> SARAH`Mom[fsFields[[i]], lorIndex]}];

   nPointFunction = {
      {fsInFields, fsOutFields},
      Insert[
         CalculateAmplitudes[amplitudes,settingsForMomElim,settingsForGenericSums,genericInsertions,
            OptionValue@Regularize,
            OptionValue@ZeroExternalMomenta,
            OptionValue@OnShellFlag
         ] /. externalMomentumRules,
         colourFactors,
         {1, -1}]
   }
];

getRestrictionsOnGenericSumsByTopology[diagrams:`type`diagramSet] :=
Module[
   {
     processParticles = Delete[#,Position[#,FeynArts`Index[Global`Colour,_Integer]]] &/@ Flatten[List@@(getProcess@diagrams)],
     newDiagrams = diagrams
   },
   newDiagrams = If[`topologyQ`self1pinguinT@First@#,
      (* Skip sum if FeynArts`Field@6 is the same as external particle 1 *)
      First@# -> Table[{6 -> Or[ processParticles[[1]],-processParticles[[1]] ]},{Length@Last@#}],
      #] &/@ diagrams;

   newDiagrams = If[`topologyQ`self3pinguinT@First@#,
      (* Skip sum if FeynArts`Field@6 is the same as external particle 3 *)
      First@# -> Table[{6 -> Or[ processParticles[[3]],-processParticles[[3]] ]},{Length@Last@#}],
      #] &/@ newDiagrams;

   (*No more rules*)
   newDiagrams = If[MatchQ[#,Rule[`type`topology,{__}]],
      #,
      (* Empty rules to skip *)
      First@#->Table[{},{Length@Last@#}]
      ] &/@ newDiagrams;
   (* Simpler external form. *)
   newDiagrams = Last /@ newDiagrams;
   newDiagrams = Flatten[List@@newDiagrams,1];
   If[MatchQ[newDiagrams,{{Rule[_Integer,_]...}..}],newDiagrams,Print@"@todo FAILED";Quit[1]]
];
getRestrictionsOnGenericSumsByTopology // Utils`MakeUnknownInputDefinition;
getRestrictionsOnGenericSumsByTopology ~ SetAttributes ~ {Protected,Locked};

getAdjacencyMatrix[topology:`type`topology] :=
Module[
   {
      propagatorPattern,needNewNumbers,adjacencies,adjacencyMatrix
   },
   propagatorPattern[i_,j_,f___] := _[_][_[_][i],_[_][j],f];
   needNewNumbers = And[Max@@(topology/.propagatorPattern[i_,j_,___]:>Sequence[i,j])>100,MatchQ[List@@topology,{propagatorPattern[_,_]..}]];
   adjacencies = Tally[(List@@#)/.propagatorPattern[i_,j_,___]:>{{i,j},{j,i}}] &@ If[needNewNumbers,FeynArts`TopologySort@#,#] &@ topology;
   adjacencyMatrix=Normal@SparseArray@Flatten[{#[[1,1]]->#[[2]],#[[1,2]]->#[[2]]} &/@ adjacencies]
];
getAdjacencyMatrix // Utils`MakeUnknownInputDefinition;
getAdjacencyMatrix ~ SetAttributes ~ {Protected,Locked};

`restrictions`momenta =
{
   {
      `topologyQ`pinguinT->2,
      `topologyQ`boxS->2,
      `topologyQ`boxT->2,
      `topologyQ`boxU->2
   },
   Default->Automatic
};

getMomElimForAmplitudesByTopology::usage=
"@brief Uses internally defined replacement list funMomRules for definition of
momenta to eliminate in specific topologies.
@param <FeynArts`TopologyList> diagrams Set of topologies with class insertions.
@returns {_Integer... | Automatic...} List of option values for FormCalc`MomElim
for every generic amplitude.";
getMomElimForAmplitudesByTopology::errOverlap=
"Some topology rules inside funMomRules overlap. Criteria should be defined in a
way, which gives unique distinction of topology.";
getMomElimForAmplitudesByTopology[
   diagrams:`type`diagramSet
] :=
Module[
   {
      replacements
   },
   replacements = (getTopologyAmplitudeRulesByTopologyCriterion[diagrams,First@#]/.x_Integer:>Last@#) &/@ `restrictions`momenta[[1]];
   replacements = Transpose@replacements;
   replacements = Switch[ Count[First/@#,True],
      0,First@#,
      1,#~Extract~Position[#,True][[1,1]],
      _,Utils`AssertOrQuit[False,getMomElimForAmplitudesByTopology::errOverlap]
      ] &/@ replacements;
   replacements = If[First@#===False,#/.x_Integer:>`restrictions`momenta[[2,2]],#] &/@ replacements;
   Flatten[Last/@replacements]
];
getMomElimForAmplitudesByTopology // Utils`MakeUnknownInputDefinition;
getMomElimForAmplitudesByTopology ~ SetAttributes ~ {Protected,Locked};

getModifiedDA::usage =
"@brief Changes amplitudes and diagrams according to excudeProcess list.
@param {<TopologyList>,<FeynAmpList>} set of topology-insertion and
amplitude-insertion rules to modify.
@param <List> set of names which specify the process to consider.
@returns {<TopologyList>,<FeynAmpList>} modified set, which specifies process.";
getModifiedDA[{diagrams:`type`diagramSet,amplitudes:`type`amplitudeSet},excludeProcesses_] := getModifiedDA[{diagrams,amplitudes},{excludeProcesses}];
getModifiedDA[
   {
      diagrams:`type`diagramSet,
      amplitudes:`type`amplitudeSet
   },
   excludeProcesses:{___}
] :=
Module[
   {
      i,numAmp,daPairs,numbersOfAmplitudes,massesOfVector,currentAmplitude,massPosition,
      rulesForClassesToSave, newDiagrams = diagrams, newAmplitudes = amplitudes
   },
   If[MemberQ[excludeProcesses,FourFermionMassiveVectorPenguins],
      Print@"t-pinguins: tree-like massless vector bosons were removed";
      (* Step 1: Get positions of topologies and amplitudes to change. *)
      daPairs = getTopologyAmplitudeRulesByTopologyCriterion[newDiagrams,`topologyQ`pinguinT];
      numbersOfAmplitudes = Flatten@Cases[daPairs,Rule[True,nums_]:>nums];
      (* Step 2: Get positions of classes to save. {<amplitude>->{classes to save}..}*)
      rulesForClassesToSave=Reap[
         Do[
            numAmp = Part[numbersOfAmplitudes,i];
            currentAmplitude = newAmplitudes[[numAmp]];
            massPosition = Position[currentAmplitude[[4,1]],genericMass[FeynArts`V, 5]];
            If[massPosition=!={},
               massesOfVector = (And@@(#=!=0&/@#)&@Extract[#,massPosition]) &/@ currentAmplitude[[4,2]];
               Sow[numbersOfAmplitudes[[i]]->Array[If[massesOfVector[[#]],#,(##&)[]]&,Length@massesOfVector]];,
               Sow[numbersOfAmplitudes[[i]]->All];
            ];
         ,{i,Length@numbersOfAmplitudes}]
      ][[2,1]];
      newAmplitudes = deleteClasses[newAmplitudes,daPairs,rulesForClassesToSave];
      newDiagrams = deleteClasses[newDiagrams,daPairs,rulesForClassesToSave];
      printDiagramsInfo@newDiagrams;
   ];
   If[MemberQ[excludeProcesses,FourFermionFlavourChangingBoxes],
      Print@"boxes: massless vector bosons were removed";
      (* Step 1: Get positions of topologies and amplitudes to change. *)
      daPairs = getTopologyAmplitudeRulesByTopologyCriterion[newDiagrams,`topologyQ`box];
      numbersOfAmplitudes = Flatten@Cases[daPairs,Rule[True,nums_]:>nums];
      (* Step 2: Get positions of classes to save. {<amplitude>->{classes to save}..}*)
      rulesForClassesToSave=Reap[
         Do[
            numAmp = numbersOfAmplitudes[[i]];
            currentAmplitude = newAmplitudes[[numAmp]];
            massPosition = Position[currentAmplitude[[4,1]],genericMass@FeynArts`V];
            If[massPosition=!={},
               massesOfVector = (And@@(#=!=0&/@#)&@Extract[#,massPosition]) &/@ currentAmplitude[[4,2]];
               Sow[numbersOfAmplitudes[[i]]->Array[If[massesOfVector[[#]],#,(##&)[]]&,Length@massesOfVector]];,
               Sow[numbersOfAmplitudes[[i]]->All];
            ];
         ,{i,Length@numbersOfAmplitudes}]
      ][[2,1]];
      newAmplitudes = deleteClasses[newAmplitudes,daPairs,rulesForClassesToSave];
      newDiagrams = deleteClasses[newDiagrams,daPairs,rulesForClassesToSave];
      printDiagramsInfo@newDiagrams;
   ];
   {newDiagrams,newAmplitudes}
];
getModifiedDA // Utils`MakeUnknownInputDefinition;
getModifiedDA ~ SetAttributes ~ {Protected,Locked};

deleteClasses[amplitudes:`type`amplitudeSet,topoAmpList:`type`pickTopoAmp,classesToSave:`type`saveAmpClass] :=
Module[{i,numbersOfAmplitudes,numAmp,result = amplitudes},
   numbersOfAmplitudes = Flatten@Cases[topoAmpList,Rule[True,nums_]:>nums];
   Do[
      numAmp = Part[numbersOfAmplitudes,i];
      result[[numAmp,4,2]] = result[[numAmp,4,2]][[numAmp/.classesToSave]];
   ,{i,Length@numbersOfAmplitudes}];
   result
];
deleteClasses[diagrams:`type`diagramSet,topoAmpList:`type`pickTopoAmp,classesToSave:`type`saveAmpClass] :=
Module[{i,currentClasses,result = diagrams},
   Do[
      If[topoAmpList[[i,1]]===True,
         currentClasses = topoAmpList[[i,2]]/.classesToSave;
         currentClasses = Array[Rule[{#,2},result[[i,2,#,2]][[Part[currentClasses,#]]]]&,Length@currentClasses];
         result[[i,2]] = ReplacePart[result[[i,2]],currentClasses];
      ];
   ,{i,Length@topoAmpList}];
   result
];
deleteClasses // Utils`MakeUnknownInputDefinition;
deleteClasses ~ SetAttributes ~ {Protected,Locked};

getTopologyAmplitudeRulesByTopologyCriterion::usage=
"@brief Gives numbers of amplitudes which are accepted by a criterion on topology.
@param <TopologyList> diagrams Set of diagrams to select from.
@param <one argument function> critFunction Function for topology selection. If
critFunction[<topology>] gives True, then topology is accepted.
@returns {<Rule>} List of rules of the form <boolean>->{<integer>..}. LHS
stands for the topology, RHS gives numbers of classes (and the numbers of
amplitudes the same time).";
getTopologyAmplitudeRulesByTopologyCriterion::errResult=
"Output
`1`
does not match desired pattern.

Input values
`2`
`3`";
getTopologyAmplitudeRulesByTopologyCriterion[
   diagrams:`type`diagramSet,
   critFunction_
] :=
Module[
   {
      topologies = List@@First/@diagrams,
      genNums = Length/@(List@@Last/@diagrams),
      numRegions,takeOrNot,res
   },
   numRegions = Array[Range[Plus@@genNums[[1;;#-1]]+1,Plus@@genNums[[1;;#]]]&,Length@genNums];
   takeOrNot = Array[TrueQ@critFunction@Part[topologies,#]&,Length@topologies];
   res = MapThread[#1->#2&,{takeOrNot,numRegions}];
   If[MatchQ[res, {Rule[_?(# === True || # === False &), {__Integer}] ..}],
      res,
      Utils`AssertOrQuit[False,getTopologyAmplitudeRulesByTopologyCriterion::errResult,res,Unevaluated@diagrams,Unevaluated@critFunction];
   ]
];
getTopologyAmplitudeRulesByTopologyCriterion // Utils`MakeUnknownInputDefinition;
getTopologyAmplitudeRulesByTopologyCriterion ~ SetAttributes ~ {Protected,Locked};

topologyReplacements::usage =
"@brief List of topology replacement rules for a processes to keep.
@note R.h.s. should be pure functions of one argument.";
topologyReplacements =
{
   Irreducible -> (FreeQ[#,FeynArts`Internal]&), (*@todo something weird with this definition*)
   Triangles -> (FreeQ[FeynArts`ToTree@#,FeynArts`Centre@Except@3]&),
   FourFermionFlavourChangingBoxes -> (`topologyQ`box@#&),
   FourFermionScalarPenguins -> (`topologyQ`pinguinT@#&),
   FourFermionMassiveVectorPenguins -> (`topologyQ`pinguinT@#&)
};
topologyReplacements ~ SetAttributes ~ {Protected,Locked};

getExcludedTopologies::usage =
"@brief Registers and returns a function, whose outcome - True or everything
else - determines whether the topology is kept or discarded (see FeynArts
manual).
@param {} or _Symbol or {_Symbol} or {__Symbol} Name(s) of processes to hold.
@returns _Symbol Generated name of topologies to hold.";
getExcludedTopologies[{}] := {};
getExcludedTopologies[{sym_Symbol}] := getExcludedTopologies@sym;
getExcludedTopologies[syms:{__Symbol}] :=
Module[{excludeTopologyName},
   FeynArts`$ExcludeTopologies[excludeTopologyName] = (Or @@ Through[(syms/.topologyReplacements)@#])&;
   excludeTopologyName];
getExcludedTopologies[sym_Symbol] :=
Module[{excludeTopologyName},
   FeynArts`$ExcludeTopologies[excludeTopologyName] = sym/.topologyReplacements;
   excludeTopologyName];
getExcludedTopologies // Utils`MakeUnknownInputDefinition;
getExcludedTopologies ~ SetAttributes ~ {Protected,Locked};

`topologyQ`pinguinT[topology:`type`topology] :=
Or[
   `topologyQ`trianglepinguinT@topology,
   `topologyQ`self1pinguinT@topology,
   `topologyQ`self3pinguinT@topology
];
`topologyQ`pinguinT // Utils`MakeUnknownInputDefinition;
`topologyQ`pinguinT ~ SetAttributes ~ {Protected,Locked};

`topologyQ`trianglepinguinT[topology:`type`topology] :=
getAdjacencyMatrix@topology === {{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{1,0,0,0,0,0,1,1},{0,1,0,1,0,0,0,1},{0,0,1,0,1,0,0,1},{0,0,0,0,1,1,1,0}};
`topologyQ`trianglepinguinT // Utils`MakeUnknownInputDefinition;
`topologyQ`trianglepinguinT ~ SetAttributes ~ {Protected,Locked};

`topologyQ`self1pinguinT[topology:`type`topology] :=
getAdjacencyMatrix@topology === {{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{1,0,0,0,0,0,0,2},{0,1,0,1,0,0,1,0},{0,0,1,0,0,1,0,1},{0,0,0,0,2,0,1,0}};
`topologyQ`self1pinguinT // Utils`MakeUnknownInputDefinition;
`topologyQ`self1pinguinT ~ SetAttributes ~ {Protected,Locked};

`topologyQ`self3pinguinT[topology:`type`topology] :=
getAdjacencyMatrix@topology === {{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{1,0,0,0,0,1,0,1},{0,1,0,1,1,0,0,0},{0,0,1,0,0,0,0,2},{0,0,0,0,1,0,2,0}};
`topologyQ`self3pinguinT // Utils`MakeUnknownInputDefinition;
`topologyQ`self3pinguinT ~ SetAttributes ~ {Protected,Locked};

`topologyQ`boxS[topology:`type`topology] :=
getAdjacencyMatrix@topology === {{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0},{0,0,0,0,0,0,0,1},{1,0,0,0,0,1,1,0},{0,1,0,0,1,0,0,1},{0,0,1,0,1,0,0,1},{0,0,0,1,0,1,1,0}};
`topologyQ`boxS // Utils`MakeUnknownInputDefinition;
`topologyQ`boxS ~ SetAttributes ~ {Protected,Locked};

`topologyQ`boxT[topology:`type`topology] :=
getAdjacencyMatrix@topology === {{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0},{0,0,0,0,0,0,0,1},{1,0,0,0,0,1,0,1},{0,1,0,0,1,0,1,0},{0,0,1,0,0,1,0,1},{0,0,0,1,1,0,1,0}};
`topologyQ`boxT // Utils`MakeUnknownInputDefinition;
`topologyQ`boxT ~ SetAttributes ~ {Protected,Locked};

`topologyQ`boxU[topology:`type`topology] :=
getAdjacencyMatrix@topology === {{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0},{0,0,0,0,0,0,0,1},{1,0,0,0,0,0,1,1},{0,1,0,0,0,0,1,1},{0,0,1,0,1,1,0,0},{0,0,0,1,1,1,0,0}};
`topologyQ`boxU // Utils`MakeUnknownInputDefinition;
`topologyQ`boxU ~ SetAttributes ~ {Protected,Locked};

`topologyQ`box[topology:`type`topology] :=
Or[`topologyQ`boxS@topology,`topologyQ`boxT@topology,`topologyQ`boxU@topology];
`topologyQ`box // Utils`MakeUnknownInputDefinition;
`topologyQ`box ~ SetAttributes ~ {Protected,Locked};

getModifiedDiagrams::usage =
"@brief Modifies diagrams according to excudeProcess list.
@param <TopologyList> set of topology-insertion rules to modify.
@param <List> set of names which specify the process to consider.
@returns <TopologyList> modified set of diagrams.";
getModifiedDiagrams[
   inserted:`type`diagramSet,
   excludeProcesses_
] :=
getModifiedDiagrams[inserted,{excludeProcesses}];
getModifiedDiagrams[
   inserted:`type`diagramSet,
   excludeProcesses:{___}] :=
Module[
   {
      newInserted = inserted,leptonPattern
   },
   If[Not[MemberQ[excludeProcesses,FourFermionScalarPenguins]&&
          MemberQ[excludeProcesses,FourFermionMassiveVectorPenguins]],
      If[MemberQ[excludeProcesses,FourFermionScalarPenguins],
         newInserted = If[`topologyQ`pinguinT[#[[1]]],
            #[[1]]->FeynArts`DiagramSelect[#[[2]],FreeQ[#,FeynArts`Field@5->FeynArts`V]&],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print@"t-penguins: tree-like vector bosons were removed";
         printDiagramsInfo@newInserted;
      ];
      If[MemberQ[excludeProcesses,FourFermionMassiveVectorPenguins],
         newInserted = If[`topologyQ`pinguinT[#[[1]]],
            #[[1]]->FeynArts`DiagramSelect[#[[2]],FreeQ[#,FeynArts`Field@5->FeynArts`S]&],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print@"t-penguins: tree-like scalar bosons were removed";
         printDiagramsInfo@newInserted;
      ];
   ];
   If[Or@@(MemberQ[excludeProcesses,#]&/@{FourFermionScalarPenguins,FourFermionMassiveVectorPenguins}),
         leptonPattern = getField[newInserted,1]/.index:`type`indexGen:>Blank[];
         newInserted = If[`topologyQ`self1pinguinT[#[[1]]],
            #[[1]]->removeGenericInsertionsBy[#[[2]],FeynArts`Field[7|8]->leptonPattern],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         leptonPattern = getField[newInserted,3]/.index:`type`indexGen:>Blank[];
         newInserted = If[`topologyQ`self3pinguinT[#[[1]]],
            #[[1]]->removeGenericInsertionsBy[#[[2]],FeynArts`Field[7|8]->leptonPattern],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print@"t-penguins: external leptons in sed-like processes were removed";
         printDiagramsInfo@newInserted;

         leptonPattern = getField[newInserted,1]/.index:`type`indexGen:>Blank[];
         newInserted = If[`topologyQ`trianglepinguinT[#[[1]]],
            #[[1]]->removeGenericInsertionsBy[#[[2]],FeynArts`Field[6|7]->leptonPattern],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print@"t-penguins: external leptons in triangle loop were removed";
         printDiagramsInfo@newInserted;
   ];
   If[MemberQ[excludeProcesses,FourFermionFlavourChangingBoxes],
         leptonPattern = getField[newInserted,1]/.index:`type`indexGen:>Blank[];
         newInserted = If[`topologyQ`boxS[#[[1]]],
            #[[1]]->removeGenericInsertionsBy[#[[2]],FeynArts`Field[6]->leptonPattern],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print["s-boxes: loops with initial lepton are removed"];
         printDiagramsInfo@newInserted;
   ];
   If[MemberQ[excludeProcesses,FourFermionFlavourChangingBoxes],

         newInserted = If[`topologyQ`boxT[#[[1]]],
            Print["Warning: t-boxes are non-zero: @todo implement rules"];#,
            #] &/@ newInserted;

         leptonPattern = getField[newInserted,1]/.index:`type`indexGen:>Blank[];
         newInserted = If[`topologyQ`boxU[#[[1]]],
            #[[1]]->removeGenericInsertionsBy[#[[2]],FeynArts`Field[5]->leptonPattern],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print["u-boxes: loops with initial lepton were deleted"];
         printDiagramsInfo@newInserted;
   ];
   newInserted
];
getModifiedDiagrams // Utils`MakeUnknownInputDefinition;
getModifiedDiagrams ~ SetAttributes ~ {Protected,Locked};

removeTopologiesWithoutInsertions[diagrams:`type`nullableDiagramSet] :=
   diagrams /. (FeynArts`Topology[_][__]->FeynArts`Insertions[Generic][]):>(##&[]);
removeTopologiesWithoutInsertions // Utils`MakeUnknownInputDefinition;
removeTopologiesWithoutInsertions ~ SetAttributes ~ {Protected,Locked};

removeClassInsertionsBy[classInsertions:FeynArts`Insertions[FeynArts`Classes][__],pattern___] :=
Module[{i,classList},
   classList = Cases[classInsertions,Except[FeynArts`FeynmanGraph[_Integer,FeynArts`Classes==_Integer][___,Sequence@@{pattern},___]]];
   If[classList=!={},
      classList=Table[classList[[i]]/.Equal[FeynArts`Classes,x_Integer]:>FeynArts`Classes==i,{i,Length@classList}]
   ];
   Head[classInsertions]@@classList
];
removeClassInsertionsBy // Utils`MakeUnknownInputDefinition;
removeClassInsertionsBy ~ SetAttributes ~ {Protected,Locked};

removeGenericInsertionsBy[genericInsertions:FeynArts`Insertions[Generic][__],pattern___] :=
Module[{i,genericList},
   genericList = Rule[#[[1]],removeClassInsertionsBy[#[[2]],pattern]] &/@ genericInsertions;
   genericList = genericList /. Rule[FeynArts`FeynmanGraph[_Integer,Generic==_Integer][__],FeynArts`Insertions[FeynArts`Classes][]] :> (##&[]);
   If[genericList=!=FeynArts`Insertions[Generic][],
      genericList = Table[genericList[[i]]/.Equal[Generic,x_Integer]:>Generic==i,{i,Length@genericList}]
   ];
   Head[genericInsertions]@@genericList
];
removeGenericInsertionsBy // Utils`MakeUnknownInputDefinition;
removeGenericInsertionsBy ~ SetAttributes ~ {Protected,Locked};

printDiagramsInfo[
   diagrams:`type`diagramSet,
   where_String:" "
] :=
Module[
   {
      nGeneric = Length@Cases[diagrams,Generic==_Integer:>1,Infinity,Heads -> True],
      nClasses = Length@Cases[diagrams,FeynArts`Classes==_Integer:>1,Infinity,Heads -> True]
   },
   Print[where,"in total: ",nGeneric," Generic, ",nClasses," Classes insertions"];
];
printAmplitudesInfo[
   amplitudes:FeynArts`FeynAmpList[__][FeynArts`FeynAmp[__,{__}->FeynArts`Insertions[FeynArts`Classes][{__}..]]..],
   where_String:"new"
] :=
Module[
   {
      nGeneric = Length@amplitudes,
      nClasses = Plus@@(Length[#[[4,2]]]&/@amplitudes)
   },
   Print[where,": in total: ",nGeneric," Generic, ",nClasses," Classes amplitudes"];
];

debugMakePictures[
   diagrams:`type`diagramSet,
   name_String:"classes"
] :=
Module[
   {
      directory = FileNameJoin[Most[FileNameSplit@@FeynArts`$Model]]
   },
   DeleteFile[FileNames[FileNameJoin@{directory, name<>"*"}]];
   Export[FileNameJoin@{directory,name<>".png"},FeynArts`Paint[diagrams,
      FeynArts`PaintLevel->{FeynArts`Classes},
      FeynArts`SheetHeader->name,
      FeynArts`Numbering->FeynArts`Simple]];
];

GenericInsertionsForDiagram::usage=
"@brief applies FindGenericInsertions[] to a
(Topology[_]->Insertions[Generic][__]) rule.
@returns list (for a given topology) of list (for all generic fields)
of list (for all class fields) of rules {{{x->y,..},..},..}
@param 1st argument is of the form Topology[_]->Insertions[Generic][__]
from FeynArts TopologyList[__][Topology[_]->Insertions[Generic][__],___]
@param 2nd argument changes the type of output field names
@note all indices in rhs. of rules are removed";
GenericInsertionsForDiagram[_->insertGen_, keepFieldNum_:False]:=
Map[FindGenericInsertions[#,keepFieldNum]&, Apply[List,insertGen,{0,1}]];

FindGenericInsertions::usage=
"@brief generic FeynmanGraph has rules Field[num]->particleType,
class FeynmanGraph has rules Field[num]->particleClass.
This function gives pairs particleType[gen,num]->particleClass, avoiding
Field[_] mediator (if keepFieldNum==True then Field[_]->particleClass is given)
@param 1st argument is of the form
{FeynmanGraph[__][__],Insertions[Classes][__]}
@param 2nd argument changes the type of output field names
True gives Field[_] names, False gives particleClass names
@returns list (sorted; for all generic fields) of list (for all class fields)
of rules {{x->y,..},..}
@note this function is called by GenericInsertionsForDiagram[]
@note this function doesn't look at external particles
@note all indices in rhs. of rules are removed";
FindGenericInsertions[{graphGen_,insertCl_}, keepFieldNum_]:=
Module[
   {
      toGenericIndexConventionRules = Cases[graphGen,
         Rule[FeynArts`Field[index_Integer],type_Symbol] :>
         Rule[FeynArts`Field@index, type[FeynArts`Index[Generic,index]]]
      ],
      fieldsGen, genericInsertions
   },
   fieldsGen = toGenericIndexConventionRules[[All,1]];
   genericInsertions = Cases[#,
      Rule[genericField_,classesField_] /; MemberQ[fieldsGen, genericField] :>
      Rule[genericField, StripParticleIndices@classesField]] &/@ insertCl;
   SortBy[#,First]&/@ If[keepFieldNum,
      List @@ genericInsertions,
      List @@ genericInsertions /. toGenericIndexConventionRules
   ]
];

StripParticleIndices::usage=
"@brief Remove particle indices from a given (possibley generic) field
@param field the given field
@returns the given field with all indices removed";
StripParticleIndices[Times[-1,field_]] :=
   Times[-1, StripParticleIndices[field]];
StripParticleIndices[genericType_[classIndex_, ___]] :=
   genericType[classIndex];

ColourFactorForDiagram::usage=
"@brief acts on a (Topology[_]->Insertions[Generic][__]) rule.
creates adjacency matrix and field array for this topology and uses this
information for creation of colour factors for a given topology
@param diagram (Topology[_]->Insertions[Generic][__]) rule
@returns list (for a given topology) of lists (for all generic fields) of
(potentially) colour factors
@note during generation of genericDiagram at 1-loop level the ii-type loop
propagators have the largest number because of FeynArts
@note in seqProp numbers of the first vertices inside propagators are sorted
by FeynArts
@note external fields always come at first places in adjacency matrix
@note this function doesn't know anything about CXXDiagrams`.` context";
ColourFactorForDiagram[
   diagram:(_[_][seqProp__]->_[_][_[__][rulesFields__]->_,___])] :=
Module[
   {
      propPatt,adjacencyMatrix,externalRules,genericDiagram,genericInsertions
   },
   propPatt[i_, j_, f_] := _[_][_[_][i], _[_][j], f];

   adjacencyMatrix = Module[
      {adjs = Tally[{seqProp}/.propPatt[i_,j_,_]:>{{i,j},{j,i}}] },
      Normal@SparseArray@Flatten[{#[[1,1]]->#[[2]],#[[1,2]]->#[[2]]} &/@ adjs]];

   externalRules = Cases[{rulesFields}, HoldPattern[_[_]->_Symbol[__]]];

   genericDiagram = Module[
      {fld = Flatten[{seqProp}/.propPatt[i_,j_,f_]:>{{j,i,-f},{i,j,f}}, 1] },
      GatherBy[SortBy[fld,First],First] /. {_Integer, _Integer, f_} :> f
      ] /. Join[ {#} -> # &/@ externalRules[[All, 1]]];

   genericInsertions = GenericInsertionsForDiagram[diagram,True];

   Map[CXXDiagrams`ColourFactorForIndexedDiagramFromGraph[
      CXXDiagrams`IndexDiagramFromGraph[
         genericDiagram /. externalRules /. #, adjacencyMatrix],
      adjacencyMatrix] &,
      genericInsertions,
      {2}]
];

CalculateAmplitudes::usage=
"@brief Calculate a given set of amplitudes.
@param amps A set of class level amplitudes as generated by
FeynArts`.`CreateFeynAmp[] (with colour indices removed)
form:
FeynAmpList[___][FeynAmp[
   GraphID[__],
   Integral[mom_],
   amp_,
   {whatIsInAmp___}->Insertion[Classes][{howToReplace___}..]]..]
@param <List> settingsForMomElim Sets up the MomElim option.
@param @todo.
@param genericInsertions the list of generic insertions for the amplitudes
@param regularizationScheme the regularization scheme for the calculation
@param zeroExternalMomenta True if external momenta should be set to zero and
False otherwise
@returns a list of the format {fsAmplitudes, subexpressions} where
fsAmplitudes denote the calculated amplitudes and subexpressions denote
the subexpressions used to simplify the expressions";
CalculateAmplitudes[
   amps:FeynArts`FeynAmpList[___,FeynArts`Process->proc_,___][feynAmps:_[__]..],
   settingsForMomElim_List,
   settingsForGenericSums:{{Rule[_Integer,_]...}..},
   genericInsertions_List,
   regularizationScheme_,
   zeroExternalMomenta_,
   onShellFlag_] :=
Module[
   {
      combinatorialFactors = CombinatorialFactorsForClasses /@ {feynAmps},
      ampsGen = FeynArts`PickLevel[Generic][amps],
      numExtParticles = Plus@@Length/@proc,
      calculatedAmplitudes,abbreviations,subexpressions,
      zeroedRules
   },
   ampsGen = If[zeroExternalMomenta===True,
      FormCalc`OffShell[ampsGen, Sequence@@Array[#->0&,numExtParticles] ], (* Relations Mom[i]^2 = 0 are true now. *)
      ampsGen];

   subWrite["\nAmplitude calculation started ...\n"];
   `time`set[];
   calculatedAmplitudes = applyAndPrint[
      FormCalc`CalcFeynAmp[Head[ampsGen][#1],
         FormCalc`Dimension -> Switch[regularizationScheme,
            DimensionalReduction, 4,
            DimensionalRegularization, D],
         FormCalc`OnShell -> onShellFlag,
         FormCalc`FermionChains -> FormCalc`Chiral,
         FormCalc`FermionOrder -> Switch[numExtParticles,4,{4,2,3,1},2,{2,1},_,None],
         FormCalc`Invariants -> False,
         FormCalc`MomElim -> #2]&,
      {ampsGen,settingsForMomElim}] //. FormCalc`GenericList[];
   subWrite["Amplitude calculation started ... done in "<>`time`get[]<>" seconds.\n"];

   calculatedAmplitudes = ToGenericSum ~ MapThread ~ {calculatedAmplitudes,settingsForGenericSums};

   abbreviations=FormCalc`Abbr[] //. FormCalc`GenericList[] /. ch:FormCalc`DiracChain[__]:>simplifySimpleChain[ch,numExtParticles];
   If[zeroExternalMomenta === OperatorsOnly, abbreviations = Expand@abbreviations /. ch:FormCalc`DiracChain[x__]*FormCalc`DiracChain[y__] :> nullifyMomentaChains@ch];
   {calculatedAmplitudes,abbreviations} = uniqueChains[calculatedAmplitudes,abbreviations];

   abbreviations = identifySpinors[abbreviations,ampsGen];
   subexpressions = FormCalc`Subexpr[] //. FormCalc`GenericList[];

   If[zeroExternalMomenta,
      abbreviations = setZeroExternalMomentaInChains@abbreviations;
      zeroedRules = Cases[FormCalc`Abbr[],
         Rule[_,pair:FormCalc`Pair[FormCalc`k[_], FormCalc`k[_]]]
         :> (pair->0)];
      {abbreviations, zeroedRules} = ZeroRules[abbreviations, zeroedRules];
      {subexpressions, zeroedRules} = ZeroRules[subexpressions, zeroedRules];
      calculatedAmplitudes = calculatedAmplitudes /. zeroedRules;];

   FCAmplitudesToFSConvention[
      {calculatedAmplitudes, genericInsertions, combinatorialFactors},
      abbreviations, subexpressions]
];

`time`time = AbsoluteTime[];
`time`time ~ SetAttributes ~ {Protected};

`time`set[] := (
   Unprotect@`time`time;
   `time`time = AbsoluteTime[];
   Protect@`time`time;
);
`time`set // Utils`MakeUnknownInputDefinition;
`time`set ~ SetAttributes ~ {Locked,Protected};

`time`get[] :=
   ToString@N[AbsoluteTime[]-`time`time,{Infinity,3}];
`time`get // Utils`MakeUnknownInputDefinition;
`time`get ~ SetAttributes ~ {Locked,Protected};


(*@Todo think how to implement this in an elegant way.*)
uniqueChains[calculatedAmplitudes_,rules:{}] :=
{calculatedAmplitudes,rules};
uniqueChains[calculatedAmplitudes_,rules:{Rule[_Symbol,_]..}] :=
Module[{chainRules,otherRules,zeroChainRules,uniqueChains,amplitudeRules},
   chainRules = Cases[rules,chain:Rule[_?(StringMatchQ[ToString@#,RegularExpression@"[F][1-9][\\d]*"]&),_]:>chain];
   otherRules = rules ~ Complement ~ chainRules;
   zeroChainRules = Cases[chainRules,chain:Rule[_,0]:>chain];
   chainRules = chainRules ~ Complement ~ zeroChainRules;
   uniqueChains = DeleteDuplicates@Cases[chainRules,FormCalc`DiracChain[x__]*FormCalc`DiracChain[y__],Infinity];
   If[uniqueChains === {},uniqueChains = DeleteDuplicates@Cases[chainRules,FormCalc`DiracChain[__],Infinity]];
   uniqueChains = MapThread[Rule[Symbol["NPointFunctions`internal`dc"<>ToString@#1],#2]&,{Range@Length@#,#}] & [uniqueChains];
   amplitudeRules = Rule[FormCalc`Mat@First@#,Last@#] &/@ (chainRules/.(uniqueChains/.Rule[x_,y_]:>Rule[y,NPointFunctions`internal`mat@x]));
   {calculatedAmplitudes/.zeroChainRules/.amplitudeRules,Join[uniqueChains,otherRules]}
];

(*@Todo think how to implement this in an elegant way.*)
simplifySimpleChain[chain_FormCalc`DiracChain,numExtParticles_Integer] :=
Module[
   {
      ch=FormCalc`DiracChain,spinor,flip,k=FormCalc`k,result
   },
   spinor[mom_:_,mass_:_,type_:1|-1] := FormCalc`Spinor[k[mom],mass,type];
   flip@7 = 6;
   flip@6 = 7;
   result = If[numExtParticles === 4,
      chain //.
      {
         ch[s1:spinor[3],proj:6|7,k@2,s2:spinor[1]] :> ch[s1,proj,k@1,s2]+ch[s1,proj,k@4,s2]-ch[s1,proj,k@3,s2],
         ch[s1:spinor[3],proj:-6|-7,k@1,k@4,s2:spinor[1,mass_]] :> FormCalc`Pair[k@4,k@1]*ch[s1,-proj,s2]-Last[s2]*mass*ch[s1,-proj,k@4,s2],
         ch[s1:spinor[4,mass_],proj:-6|-7,k@1,k@4,s2:spinor[2]] :> FormCalc`Pair[k@4,k@1]*ch[s1,-proj,s2]-Last[s1]*mass*ch[s1,flip[-proj],k@1,s2]
      },
      chain
      ];
   result //.
   {
         ch[s1:spinor[],proj:6|7,k[number_],s2:spinor[number_,mass_]] :> Last[s2]*mass*ch[s1,proj,s2],
         ch[s1:spinor[number_,mass_],proj:6|7,k[number_],s2:spinor[]] :> Last[s2]*mass*ch[s1,flip@proj,s2]
   }
];

(*@Todo think how to implement this in an elegant way.*)
nullifyMomentaChains[Times[chain1_FormCalc`DiracChain,chain2_FormCalc`DiracChain]] :=
Module[
   {
      ch=FormCalc`DiracChain,spinor,flip,k=FormCalc`k,l=FormCalc`Lor
   },
   spinor[mom_:_,mass_:_,type_:1|-1] := FormCalc`Spinor[k[mom],mass,type];
   flip@7 = 6;
   flip@6 = 7;
   chain1*chain2 /.
   {
      ch[spinor[3],6|7,k@4,spinor[1]] -> 0,
      ch[spinor[4],6|7,k@1,spinor[2]] -> 0,
      ch[spinor[3],6|7,l@1,spinor[1]]*ch[spinor[4],-6|-7,k@1,l@1,spinor[2]] -> 0,
      ch[spinor[3],-6|-7,k@4,l@1,spinor[1]]*ch[spinor[4],6|7,l@1,spinor[2]] -> 0,
      ch[spinor[3],-6|-7,k@4,l@1,spinor[1]]*ch[spinor[4],-6|-7,k@1,l@1,spinor[2]] -> 0,
      ch[spinor[3],-6|-7,k@4,l@1,l@2,spinor[1]]*ch[spinor[4],-6|-7,k@1,l@1,l@2,spinor[2]] -> 0,

      ch[spinor[3],-6|-7,k@1,k@4,l@1,spinor[1]]*ch[spinor[4],6|7,l@1,spinor[2]] -> 0,
      ch[spinor[3],6|7,l@1,spinor[1]]*ch[spinor[4],-6|-7,k@1,k@4,l@1,spinor[2]] -> 0
   }
];

setZeroExternalMomentaInChains::usage =
"@brief Sets FormCalc`k[i] to zero inside fermioinic chains.
@param abbreviations list of rules.
@returns Changed list of rules.";
setZeroExternalMomentaInChains::errUnknownInput =
"Input should be
setZeroExternalMomentaInChains@@{ <list of rules> }
and not
setZeroExternalMomentaInChains@@`1`";
setZeroExternalMomentaInChains[abbreviations:{Rule[_,_]...}] :=
Module[
   {
      replaceMomenta,temp,setZeroChainToZero
   },
   replaceMomenta[expr_] := expr/.FormCalc`k[_Integer]:>0;
   temp = abbreviations/.chain:FormCalc`DiracChain[__] :> replaceMomenta@chain;
   setZeroChainToZero[FormCalc`DiracChain[__,0,__]] := 0;
   setZeroChainToZero[chain:FormCalc`DiracChain[__]] := chain;
   temp/.chain:FormCalc`DiracChain[__] :> setZeroChainToZero@chain
];
setZeroExternalMomentaInChains[x___] :=
Utils`AssertOrQuit[False,setZeroExternalMomentaInChains::errUnknownInput,{x}];
SetAttributes[setZeroExternalMomentaInChains,{Protected,Locked}];

identifySpinors::usage =
"@brief Inserts the names of fermionic fields inside FormCalc`DicaChain structures.
@param inp List of abbreviations to modify | FormCalc`DiracChain chain to modify.
@param ampsGen FeynArts`FeynAmpList with information of process
@returns DiracChain with inserted fermion names | Expression with new DiracChains.
@note DiracChains live only inside FormCalc`Abbr.
@note Should NOT be used for Automatic FormCalc`FermionOrder.";
identifySpinors[
   inp:{Rule[_,_]...},
   ampsGen:FeynArts`FeynAmpList[
      ___,
      (FeynArts`Process->Rule[{{__}..},{{__}..}]),
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]] :=
inp/.ch:FormCalc`DiracChain[__]:>identifySpinors[ch,ampsGen];
identifySpinors[
   FormCalc`DiracChain[
      FormCalc`Spinor[FormCalc`k[fermion1_Integer],mass1_,1|-1],
      seqOfElems___,
      FormCalc`Spinor[FormCalc`k[fermion2_Integer],mass2_,1|-1]],
   FeynArts`FeynAmpList[
      ___,
      process:(FeynArts`Process->Rule[{{__}..},{{__}..}]),
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]
] :=
Module[
   {
      identificationRules = getFieldPositionRules@process
   },
   FormCalc`DiracChain[
   FormCalc`Spinor[fermion1/.identificationRules,FormCalc`k[fermion1],mass1],
   seqOfElems,
   FormCalc`Spinor[fermion2/.identificationRules,FormCalc`k[fermion2],mass2]]
];
identifySpinors // Utils`MakeUnknownInputDefinition;
identifySpinors ~ SetAttributes ~ {Protected,Locked};

getFieldPositionRules::usage =
"@brief Gives rules of the form number_of_input_field->name_of_fermion.
@param FeynArts`Process->Rule[_,_].
@returns Rules of the form number_of_input_field->name_of_fermion.";
getFieldPositionRules[
   FeynArts`Process->Rule[in:{{__}..},out:{{__}..}]
] :=
MapThread[Rule,{Range@Length@#,#//.fieldNameToFSRules}] & [Part[in,All,1]~Join~Part[out,All,1]];
getFieldPositionRules // Utils`MakeUnknownInputDefinition;
getFieldPositionRules ~ SetAttributes ~ {Protected,Locked};

getNumberOfChains::usage =
"@brief Is used to calculate number of opened fermion chains.
@param FeynArts`FeynAmpList[..][..]
@returns Number of opened fermion chains.";
getNumberOfChains::errNumberOfFermions =
"During evaluation unexpected value of fermions `1` was calculated.";
getNumberOfChains::errUnknownInput =
"Input should be
getNumberOfExternalFermions@@{ FeynArts`FeynAmpList[___][___] }
and not
getNumberOfExternalFermions@@`1`";
getNumberOfChains[
   FeynArts`FeynAmpList[
      ___,
      FeynArts`Process->Rule[in:{{__}..},out:{{__}..}],
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]
] :=
Module[{numberOfChains = 0},
   Cases[Join[in[[All,1]],out[[All,1]]],FeynArts`F[__]|-FeynArts`F[__]:>numberOfChains++,{1}];
   numberOfChains /= 2;
   If[IntegerQ@numberOfChains && numberOfChains >= 0,
      numberOfChains,
      Utils`AssertOrQuit[False,getNumberOfChains::errNumberOfFermions,numberOfChains]
   ]
];
getNumberOfChains[x___] :=
Utils`AssertOrQuit[False,getNumberOfChains::errUnknownInput,{x}]
SetAttributes[getNumberOfChains,{Protected,Locked}];

applyAndPrint[func_,{expr_,opts_List},defLength_Integer:70] :=
Module[
   {
      now,
      totL = Length@expr,
      write,
      percent,
      numOfEq,
      restL,
      result
   },
   restL=defLength-2*IntegerLength@totL-11;
   result=Reap[
      Do[
      percent = now/totL;
      numOfEq = If[#<0,0,#]&[ Floor[percent*restL]-1 ];
      subWrite@StringJoin[
         "[",StringJoin@@Array[" "&,IntegerLength@totL-IntegerLength@now],ToString@now,"/",ToString@totL,"]"," ",
         "[",StringJoin@@Array["="&,numOfEq],">",StringJoin@@Array[" "&,restL-numOfEq-1],"] ",ToString@Floor[100*percent],"%\r"];
      Sow@func[ expr[[now]], opts[[now]] ];,
      {now,totL}]
   ][[2,1]];
   subWrite@"\033[K\033[A";
   result
];

CombinatorialFactorsForClasses::usage="
@brief Takes generic amplitude and finds numerical combinatirical factors
       which arise at class level.
@returns list of combinatorical factors for a given generic amplitude
@param FeynArts`.`FeynAmp[__]";
CombinatorialFactorsForClasses[
   FeynArts`FeynAmp[_,_,_,rules_->_[_][classReplacements__]]
]:=
   {classReplacements}[[ All,#[[1,1]] ]] /.
      {
         FeynArts`IndexDelta[___] -> 1,
         FeynArts`SumOver[__] -> 1
      } &@
   Position[rules, FeynArts`RelativeCF];
CombinatorialFactorsForClasses // Utils`MakeUnknownInputDefinition;
CombinatorialFactorsForClasses ~ SetAttributes ~ {Locked,Protected};

ToGenericSum::usage=
"@todo
@brief Given a generic amplitude, determine the generic fields over which it
needs to be summed and return a corresponding GenericSum[] object.
@param FormCalc`Amp[_->_][amp_] the given generic amplitude
@returns {S|F|V|U|T[GenericIndex[number of index]]...}.";
ToGenericSum[FormCalc`Amp[_->_][amp_],genericSumRestictions:{Rule[_Integer,_]...}] :=
Module[
   {
      sortSumFields = Sort@DeleteDuplicates[Cases[amp,`type`FAfieldGeneric,Infinity]],
      replSumFields
   },
   replSumFields = sortSumFields /. f_[_[_,i_]]:>{f@GenericIndex@i,Replace[i,genericSumRestictions~Join~{_Integer->False}]};
   GenericSum[{amp}, replSumFields]
];
SetAttributes[ToGenericSum,{Protected,Locked}];

FAFieldQ::usage=
"@brief Checks whether symbol belongs to FeynArts` field names or not.
@param Symbol to check.
@returns True if symbol belongs to FeynArts` field names, False otherwise.";
FAFieldQ = MatchQ[#,`type`fieldFA]&;
SetAttributes[FAFieldQ,{Protected,Locked}];

ZeroRules::usage=
"@brief Given a set of rules that map to zero and a set that does
not map to zero, apply the zero rules to the non-zero ones
recursively until the non-zero rules do not change anymore.
@param nonzeroRules the list of nonzero rules
@param zeroRules the list of zero rules
@returns a list of rules that map the same expressions as the initial rules.
The return value is of the form {{Rule[_,_]...},{Rule[_,0]...}}";
ZeroRules[nonzeroRules:{Rule[_,_]...}, zeroRules:{Rule[_,0]...}] :=
Module[{newNonzero, newZeroRules},
   newNonzero = Thread[
      Rule[nonzeroRules[[All,1]],nonzeroRules[[All,2]] /. zeroRules]];

   If[newNonzero === nonzeroRules, Return[{nonzeroRules, zeroRules}]];

   newZeroRules = Cases[newNonzero,HoldPattern[_->0]];
   newNonzero = Complement[newNonzero, newZeroRules];

   ZeroRules[newNonzero, Join[zeroRules,newZeroRules]]
];

FCAmplitudesToFSConvention::usage=
"@brief Tranlate a list of FormCalc amplitudes and their abbreviations and
subexpressions into FlexibleSUSY language.
@param amplitudes the given list of amplitudes
@param abbreviations list of abbreviations
@param aubexpressions list of subexpressions
@returns a list of the form
`{fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}`
where all FlexibleSUSY conventions have been applied.";
FCAmplitudesToFSConvention[amplitudes_, abbreviations_, subexpressions_] :=
Module[{fsAmplitudes, fsAbbreviations, fsSubexpressions},
   fsAmplitudes = amplitudes //. amplitudeToFSRules;
   fsAbbreviations = abbreviations //. subexpressionToFSRules //. {FormCalc`DiracChain->NPointFunctions`internal`dc,FormCalc`Spinor->SARAH`DiracSpinor,FormCalc`Lor->SARAH`Lorentz};
   fsSubexpressions = subexpressions //. subexpressionToFSRules;
   {fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}
];

SetAttributes[
   {
   NPointFunctionFAFC,
   GenericInsertionsForDiagram,FindGenericInsertions,StripParticleIndices,
   ColourFactorForDiagram,
   ZeroRules,FCAmplitudesToFSConvention
   },
   {Protected, Locked}];

End[];
EndPackage[];
