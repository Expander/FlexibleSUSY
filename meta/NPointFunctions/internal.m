(* ::Package:: *)

(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

BeginPackage["NPointFunctions`",{"FeynArts`","FormCalc`","Utils`"}];
FeynArts`$FAVerbose = 1;(* Change this to 2 to see more output (if 1 then less). *)
FormCalc`$FCVerbose = 0;(* Change this to 1,2 or 3 to see more output. *)

{setInitialValues,NPointFunctionFAFC}

(* Symbols that are not distributed from main kernel. *)
SetAttributes[#,{Locked,Protected}]&@
{
   LorentzIndex,GenericSum,GenericIndex,
   GenericS,GenericF,GenericV,GenericU,GenericT,
   LoopLevel,Regularize,ZeroExternalMomenta,OnShellFlag,ExcludeProcesses
};
(* Symbols that can be distributed from main kernel. *)
If[Attributes[#]=!={Locked,Protected},SetAttributes[#,{Locked,Protected}]]&/@
{
   DimensionalReduction,DimensionalRegularization,ExceptPaVe,
   (*for further details inspect topologyReplacements*)
   ExceptIrreducible,ExceptBoxes,ExceptTriangles,ExceptFourFermionScalarPenguins,
   ExceptFourFermionMassiveVectorPenguins
};

Begin["`Private`"];
calledPreviouslysetInitialValues::usage=
"@brief is used to prohibid multiple calls of 
NPointFunctions`.`setInitialValues[].";
calledPreviouslysetInitialValues = False;

feynArtsDir = "";
formCalcDir = "";
feynArtsModel = "";
particleNamesFile = "";
substitutionsFile = "";
particleNamespaceFile = "";

subexpressionToFSRules::usage=
"A set of rules that aid translation between FeynArts and FlexibleSUSY language.
They should be applied to subexpressions generated by FeynArts.";
subexpressionToFSRules = {};

fieldNameToFSRules::usage=
"A set of rules for @todo";
fieldNameToFSRules = {};

amplitudeToFSRules::usage=
"A set of rules for @todo";
amplitudeToFSRules= {};

Protect[calledPreviouslysetInitialValues,feynArtsDir,formCalcDir,feynArtsModel,
   particleNamesFile,substitutionsFile,particleNamespaceFile,
   subexpressionToFSRules,fieldNameToFSRules,amplitudeToFSRules
];

setInitialValues::usage=
"@brief Set the FeynArts and FormCalc paths.
@param FADirS the directory designated for FeynArts output
@param FCDirS the directory designated for FormCalc output
@param FAModelS the name of the FeynArts model file
@param particleNamesFileS the name of the SARAH-generated particle names file
@param substitutionsFileS the name of the SARAH-generated substitutions file
@param particleNamespaceFileS the name of the particle namespace file
@note allowed to be called only once
@note effectively Private function";
setInitialValues::errOnce=
"NPointFunctions`.`setInitialValues[]: Multiple calls:
something tries to redefine paths for FeynArts and FormCalc";
setInitialValues[FADir_String, FCDir_String, FAModel_String,
   particleNamesFileS_String, substitutionsFileS_String,
   particleNamespaceFileS_String] :=
If[Utils`AssertOrQuit[!calledPreviouslysetInitialValues,setInitialValues::errOnce],
   ClearAttributes[
      {
         feynArtsDir,formCalcDir,feynArtsModel,
         particleNamesFile,substitutionsFile,particleNamespaceFile,
         calledPreviouslysetInitialValues
      },{Protected}];
   feynArtsDir = FADir;
   formCalcDir = FCDir;
   feynArtsModel = FAModel;
   particleNamesFile = particleNamesFileS;
   substitutionsFile = substitutionsFileS;
   particleNamespaceFile = particleNamespaceFileS;
   calledPreviouslysetInitialValues = True;
   SetAttributes[
      {
         feynArtsDir,formCalcDir,feynArtsModel,
         particleNamesFile,substitutionsFile,particleNamespaceFile,
         calledPreviouslysetInitialValues
      },{Protected, Locked}];
   SetFSConventionRules[];
];
SetAttributes[setInitialValues,{Protected,Locked}];

SetFSConventionRules::usage=
"@brief Set the translation rules from FeynArts/FormCalc to FlexibleSUSY 
language.";
SetFSConventionRules::errSARAH=
"It seems that SARAH`.` has changed conventions for
<ParticleNames>.dat file.";
SetFSConventionRules[] :=
Module[
   {
      pairSumIndex=Unique@"SARAH`lt",
      fieldNames,indexRules,massRules,couplingRules,generalFCRules,
      diracChainRules,sumOverRules
   },

   fieldNames =
   Flatten[
      StringCases[
         Utils`ReadLinesInFile@particleNamesFile, 
         x__ ~~ ": " ~~ y__ ~~ "]" ~~ ___ :> {x,y}],
      1] /. 
      Apply[Rule, {#[[1]], #[[2]] <> #[[1]]} & /@ Get@particleNamespaceFile, 2];
   Utils`AssertWithMessage[Length@fieldNames > 0,
      SetFSConventionRules::errSARAH];
   massRules = Append[Flatten[Module[
      {P="SARAH`Mass@"<>#,MassP="Mass"<>ToString@Symbol@#},
      {
         ToExpression[MassP <> "@indices_:>" <> P <> 
         "@{Symbol[\"SARAH`gt\"<>StringTake[SymbolName@indices,-1]]}"],
         ToExpression[MassP <> "@indices__:>" <> P <> "@{indices}"],
         ToExpression[MassP <> "->" <> P]
      }
      ] &/@ fieldNames[[All, 1]] ],
      FeynArts`Mass[field_, _ : Null] :> SARAH`Mass[field]
   ];

   couplingRules =
   {
      FeynArts`G[_][0][fields__][1] :> 
      SARAH`Cp[fields][1],
         
      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`ChiralityProjector[-1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PL],
      
      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`ChiralityProjector[1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PR],
      
      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`DiracMatrix@FeynArts`KI1@3,
            Global`ChiralityProjector[-1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PL],
      
      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`DiracMatrix@FeynArts`KI1@3,
            Global`ChiralityProjector[1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PR],
      
      FeynArts`G[_][0][fields__][
         Global`MetricTensor[
            KI1[i1_Integer],
            KI1[i2_Integer]
         ]
      ] :>
      SARAH`Cp[fields][
         SARAH`g[
            LorentzIndex[ {fields}[[i1]] ],
            LorentzIndex[ {fields}[[i2]] ]
         ]
      ],
         
      FeynArts`G[_][0][fields__][
         FeynArts`Mom[ i1_Integer ] - FeynArts`Mom[ i2_Integer ]
      ] :>
      SARAH`Cp[fields][
         SARAH`Mom[ {fields}[[i1]] ] - SARAH`Mom[ {fields}[[i2]] ]
      ],
      
      (*Since FormCalc-9.7*)
      FeynArts`G[_][0][fields__][
         Global`FourVector[
            FeynArts`Mom[ i1_Integer ] - FeynArts`Mom[ i2_Integer ],
            FeynArts`KI1[3]
         ]
      ] :>
      SARAH`Cp[fields][
         SARAH`Mom[ {fields}[[i1]] ] - SARAH`Mom[ {fields}[[i2]] ]
      ],

      (*@note It seems that FA convention is changed by FC.*)
      (*@note See Lorentz.gen (inside FA) for more information.*)
      (*VVV couplings*)
      FeynArts`G[-1][0][fields__][
         (-FeynArts`Mom[i1_Integer]+FeynArts`Mom[i2_Integer])*
         Global`MetricTensor[FeynArts`KI1[i1_Integer],FeynArts`KI1[i2_Integer]]
         +
         (+FeynArts`Mom[i1_Integer]-FeynArts`Mom[i3_Integer])*
         Global`MetricTensor[FeynArts`KI1[i1_Integer],FeynArts`KI1[i3_Integer]]
         +
         (-FeynArts`Mom[i2_Integer] + FeynArts`Mom[i3_Integer])*
         Global`MetricTensor[FeynArts`KI1[i2_Integer],FeynArts`KI1[i3_Integer]]
      ] :>
      SARAH`Cp[fields][
         (SARAH`Mom[{fields}[[i2]], LorentzIndex[{fields}[[i3]]]] -
         SARAH`Mom[{fields}[[i1]], LorentzIndex[{fields}[[i3]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i1]] ],LorentzIndex[ {fields}[[i2]] ] ]
         ,
         (SARAH`Mom[{fields}[[i1]], LorentzIndex[{fields}[[i2]]]] - 
         SARAH`Mom[{fields}[[i3]], LorentzIndex[{fields}[[i2]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i1]] ],LorentzIndex[ {fields}[[i3]] ] ]
         , 
         (SARAH`Mom[{fields}[[i3]], LorentzIndex[{fields}[[i1]]]] -
         SARAH`Mom[{fields}[[i2]], LorentzIndex[{fields}[[i1]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i2]] ],LorentzIndex[ {fields}[[i3]] ] ]
      ]
   };

   (* @note Sec 4.4 of FormCalc manual *)
   generalFCRules =
   {
      FormCalc`Finite -> 1,
      FormCalc`Den[a_,b_] :> 1/(a-b),
      FormCalc`Pair[a_,b_] :> SARAH`sum[
         pairSumIndex,1,4,
         SARAH`g[pairSumIndex,pairSumIndex]*Append[a,pairSumIndex]*Append[b,pairSumIndex]],
      fieldType_?(FAFieldQ)[FeynArts`Index[Generic,number_Integer]] :> fieldType@GenericIndex@number,
      FormCalc`k[i_Integer,indexInPair___] :> SARAH`Mom[i,indexInPair]
   };

   indexRules =                                                                 (* @note These index rules are specific to SARAH generated FeynArts model files.*) 
   {
      FeynArts`Index[generationName_, index_Integer] :> 
      Symbol["SARAH`gt" <> ToString@index] /;
         StringMatchQ[SymbolName@generationName, "I"~~___~~"Gen"],
      FeynArts`Index[Global`Colour, index_Integer] :>
      Symbol["SARAH`ct" <> ToString@index],
      FeynArts`Index[Global`Gluon, index_Integer] :>                            (* @todo Potentially dangerous stuff. Gluon goes from 1 to 8, not from 1 to 3 as Colour*)
      Symbol["SARAH`ct" <> ToString@index]
   };
   
   sumOverRules =
   {
      FeynArts`SumOver[_,_,FeynArts`External] :> Sequence[],
      Times[expr_,FeynArts`SumOver[index_,max_Integer]] :> 
         SARAH`sum[index,1,max,expr],
      Times[expr_,FeynArts`SumOver[index_,{min_Integer,max_Integer}]] :> 
         SARAH`sum[index,min,max,expr],
      SARAH`sum[index_,_Integer,max_Integer,FeynArts`SumOver[_,max2_Integer]] :>            (* @todo check these weird convention rules *)
         SARAH`sum[index,1,max,max2],                                                       (* *)
      SARAH`sum[index_,_Integer,max_Integer,FeynArts`SumOver[_,{min2_Integer,max2_Integer}]](* *)
    :> SARAH`sum[index,1,max,max2-min2]                                                     (* *)
};

   Unprotect@fieldNameToFSRules;
   fieldNameToFSRules = Join[
      ToExpression[#[[2]] <> "]->" <> #[[1]]] &/@ 
         fieldNames,
      ToExpression[#[[2]] <> ",{indices___}]:>" <> #[[1]] <> "[{indices}]"] &/@ 
         fieldNames,
      {
         FeynArts`S -> GenericS, FeynArts`F -> GenericF, FeynArts`V -> GenericV,
         FeynArts`U -> GenericU, FeynArts`T -> GenericT
      },
      {
         Times[-1, field_GenericS | field_GenericV] :>
         Susyno`LieGroups`conj@field,
         Times[-1, field_GenericF | field_GenericU] :>
         SARAH`bar@field
      },
      (Times[-1, field: # | Blank@#] :> CXXDiagrams`LorentzConjugate@field) &/@ (* @todo for what is this? *)
         (ToExpression /@ fieldNames[[All,1]]),                                 (* *)
      indexRules
   ];
   Protect@fieldNameToFSRules;

   (*These symbols cause an overshadowing with Susyno`LieGroups @todo what is this*)
   diracChainRules = Symbol["F" <> ToString@#] :> Unique@"diracChain" &/@ 
      Range@Length@fieldNames;
   
   Unprotect@subexpressionToFSRules;
   subexpressionToFSRules = Join[
      massRules,
      fieldNameToFSRules,
      couplingRules,
      generalFCRules,
      diracChainRules
   ];
   Protect@subexpressionToFSRules;
   
   Unprotect@amplitudeToFSRules;
   amplitudeToFSRules = Join[
      subexpressionToFSRules,
      sumOverRules,
      {FeynArts`IndexSum -> Sum}
   ];
   Protect@amplitudeToFSRules;
];

Options[NPointFunctionFAFC]={
   LoopLevel -> 1,
   Regularize -> DimensionalReduction,
   ZeroExternalMomenta -> True,
   OnShellFlag -> False,
   ExcludeProcesses -> {}
};
NPointFunctionFAFC::usage=
"@note effectively Private function, see usage of NPointFunction[]";
NPointFunctionFAFC[inFields_,outFields_,OptionsPattern[]] :=
Module[
   {
      settingsForGenericSums,settingsForMomElim,
      topologies, diagrams, amplitudes, genericInsertions, colourFactors, 
      fsFields, fsInFields, fsOutFields, externalMomentumRules, nPointFunction
   },

   If[!DirectoryQ@formCalcDir,CreateDirectory@formCalcDir];
   SetDirectory@formCalcDir;

   topologies = FeynArts`CreateTopologies[OptionValue@LoopLevel,
      Length@inFields -> Length@outFields,
      FeynArts`ExcludeTopologies -> getExcludedTopologies@OptionValue@ExcludeProcesses];

   diagrams = FeynArts`InsertFields[topologies,
      inFields -> outFields,
      FeynArts`InsertionLevel -> FeynArts`Classes,
      FeynArts`Model -> feynArtsModel];
   diagrams = getModifiedDiagrams[diagrams,OptionValue@ExcludeProcesses];

   amplitudes = FeynArts`CreateFeynAmp@diagrams;
   amplitudes = Delete[amplitudes,Position[amplitudes,FeynArts`Index[Global`Colour,_Integer]]];(* @note Remove colour indices following assumption 1. *)
   {diagrams,amplitudes} = getModifiedDA[{diagrams,amplitudes},OptionValue@ExcludeProcesses];

   settingsForGenericSums = getRestrictionsOnGenericSumsByTopology@diagrams;
   settingsForMomElim = getMomElimForAmplitudesByTopology@diagrams;

   genericInsertions = Map[Last,#,{3}] &@ Flatten[                              (* Everything is sorted already, so we need only field-replacement names *)
      GenericInsertionsForDiagram /@ (List @@ diagrams), 1];

   colourFactors = Flatten[
      ColourFactorForDiagram /@ (List @@ diagrams), 1] //.
      fieldNameToFSRules;
   
   fsInFields = Head[amplitudes][[1,2,1,All,1]] //. fieldNameToFSRules;
   fsOutFields = Head[amplitudes][[1,2,2,All,1]] //. fieldNameToFSRules;

   fsFields = Join[fsInFields,fsOutFields];
   externalMomentumRules = Switch[OptionValue@ZeroExternalMomenta,
      True, {SARAH`Mom[_Integer,_] :> 0},
      False, {SARAH`Mom[i_Integer, lorIndex_] :> SARAH`Mom[fsFields[[i]], lorIndex]},
      ExceptPaVe,{}(* @todo Modify. *)];
   nPointFunction = {
      {fsInFields, fsOutFields},
      Insert[
         CalculateAmplitudes[amplitudes,settingsForMomElim,settingsForGenericSums,genericInsertions,
            OptionValue@Regularize,
            OptionValue@ZeroExternalMomenta,
            OptionValue@OnShellFlag
         ] /. externalMomentumRules,
         colourFactors,
         {1, -1}]
   }
];

getRestrictionsOnGenericSumsByTopology[
   diagrams:FeynArts`TopologyList[___,FeynArts`Process->inProcess:_,___][Rule[FeynArts`Topology[_][__],_]..]
] :=
Module[
   {
     processParticles = Delete[#,Position[#,FeynArts`Index[Global`Colour,_Integer]]] &/@ Flatten[List@@inProcess],
     newDiagrams
   },
   (* 2to2 self energy of particle 1. *)
   newDiagrams = If[getAdjacencyMatrixForTopology@First@# === {{0,0,0,0,1,0,0,0},
                                                               {0,0,0,0,0,1,0,0},
                                                               {0,0,0,0,0,0,1,0},
                                                               {0,0,0,0,0,1,0,0},
                                                               {1,0,0,0,0,0,0,2},
                                                               {0,1,0,1,0,0,1,0},
                                                               {0,0,1,0,0,1,0,1},
                                                               {0,0,0,0,2,0,1,0}},
      (* Skip sum if FeynArts`Field@6 is the same as external particle 3 *)
      Table[{6 -> Or[ processParticles[[1]],-processParticles[[1]] ]},{Length@Last@#}],
      #] &/@ diagrams;
   (* 2to2 self energy of particle 3. *)
   newDiagrams = If[getAdjacencyMatrixForTopology@First@# === {{0,0,0,0,1,0,0,0},
                                                               {0,0,0,0,0,1,0,0},
                                                               {0,0,0,0,0,0,1,0},
                                                               {0,0,0,0,0,1,0,0},
                                                               {1,0,0,0,0,1,0,1},
                                                               {0,1,0,1,1,0,0,0},
                                                               {0,0,1,0,0,0,0,2},
                                                               {0,0,0,0,1,0,2,0}},
      (* Skip sum if FeynArts`Field@6 is the same as external particle 3 *)
      Table[{6 -> Or[ processParticles[[3]],-processParticles[[3]] ]},{Length@Last@#}],
      #] &/@ newDiagrams;
   (*No more rules*)
   newDiagrams = If[MatchQ[#,Rule[FeynArts`Topology[_Integer][__],_]],
      (* Empty rules to skip *)
      Table[{},{Length@Last@#}],
      #] &/@ newDiagrams;
   (* Simpler external form. *)
   newDiagrams = Flatten[List@@newDiagrams,1];
   If[MatchQ[newDiagrams,{{Rule[_Integer,_]...}..}],newDiagrams,Print@"@todo FAILED";Quit[1]]
];

getAdjacencyMatrixForTopology[
   topology:FeynArts`Topology[_Integer][seqProp:FeynArts`Propagator[ FeynArts`External|FeynArts`Incoming|FeynArts`Outgoing|FeynArts`Internal|FeynArts`Loop[_Integer] ][ FeynArts`Vertex[_Integer][_Integer],FeynArts`Vertex[_Integer][_Integer],Repeated[FeynArts`Field[_Integer],{0,1}]]..]
]:=
Module[
   {
      propagatorPattern,adjacencies,adjacencyMatrix
   },
   propagatorPattern[i_,j_,f___] := _[_][_[_][i],_[_][j],f];
   adjacencies = Tally[{seqProp}/.propagatorPattern[i_,j_,_]:>{{i,j},{j,i}}];
   adjacencyMatrix=Normal@SparseArray@Flatten[{#[[1,1]]->#[[2]],#[[1,2]]->#[[2]]} &/@ adjacencies]
];

getMomElimForAmplitudesByTopology::usage=
"@brief Uses internally defined replacement list funMomRules for definition of
momenta to eliminate in specific topologies.
@param <FeynArts`TopologyList> diagrams Set of topologies with class insertions.
@returns {_Integer... | Automatic...} List of option values for FormCalc`MomElim
for every generic amplitude.";
getMomElimForAmplitudesByTopology::errUnknownInput=
"Input should be <FeynArts`.`TopologyList> and not
`1`";
getMomElimForAmplitudesByTopology::errOverlap=
"Some topology rules inside funMomRules overlap. Criteria should be defined in a
way, which gives unique distinction of topology.";
getMomElimForAmplitudesByTopology[
   diagrams:FeynArts`TopologyList[__][Rule[FeynArts`Topology[_][__],_]..]
] :=
Module[
   {
      aoq=Utils`AssertOrQuit,
      getTAR = getTopologyAmplitudeRulesByTopologyCriterion,
      funMomRules = {amITPinguin->2},
      replacements
   },
   replacements = (getTAR[diagrams,First@#] /.x_Integer:>Last@#) &/@ funMomRules;
   replacements = Transpose@replacements;
   replacements = Switch[ Count[First/@#,True],
      0,First@#,
      1,#~Extract~Position[#,True][[1,1]],
      _,aoq[False,getMomElimForAmplitudesByTopology::errOverlap]
      ] &/@ replacements;
   replacements = If[First@#===False,#/.x_Integer:>Automatic,#] &/@ replacements;
   Flatten[Last/@replacements]
];
getMomElimForAmplitudesByTopology[x___] :=
Utils`AssertOrQuit[False,getMomElimForAmplitudesByTopology::errUnknownInput,{x}];
SetAttributes[getMomElimForAmplitudesByTopology,{Protected,Locked,ReadProtected}];

getModifiedDA::usage = 
"@brief Changes amplitudes and diagrams according to excudeProcess list.
@param {<TopologyList>,<FeynAmpList>} set of topology-insertion and 
amplitude-insertion rules to modify.
@param <List> set of names which specify the process to consider.
@returns {<TopologyList>,<FeynAmpList>} modified set, which specifies process.";
getModifiedDA::errUnknownInput=
"Input should be
getModifiedDA@@{ {<TopologyList>,<FeynAmpList>}, <List> }
and not
getModifiedDA@@`1`";
getModifiedDA[{diagrams_,amplitudes_},excludeProcesses_] :=
getModifiedDA[{diagrams,amplitudes},{excludeProcesses}];
getModifiedDA[
   {
      diagrams:FeynArts`TopologyList[__][Rule[FeynArts`Topology[_][__],_]..],
      amplitudes:FeynArts`FeynAmpList[__][FeynArts`FeynAmp[__,{__}->FeynArts`Insertions[FeynArts`Classes][{__}..]]..]
   },
   excludeProcesses:{___}
] :=
Module[
   {
      i,numAmp,daPairs,numbersOfAmplitudes,massesOfVector,currentAmplitude,massPosition,
      rulesForClassesToSave, newDiagrams = diagrams, newAmplitudes = amplitudes,
      currentClasses
   },
   If[MemberQ[excludeProcesses,ExceptFourFermionMassiveVectorPenguins],
      Print["MA: penguins: stu propagation of massless bosons is excluded"];
      (* Step 1: Get positions of topologies and amplitudes to change. *)
      daPairs = getTopologyAmplitudeRulesByTopologyCriterion[diagrams,amITPinguin];
      numbersOfAmplitudes = Flatten[If[#[[1]]===True,#[[2]],(##&)[]]&/@daPairs];
      (* Step 2: Get positions of classes to save. {<amplitude>->{classes to save}..}*)
      rulesForClassesToSave=Reap[
         Do[
            numAmp = Part[numbersOfAmplitudes,i];
            currentAmplitude = amplitudes[[numAmp]];
            massPosition = Position[currentAmplitude[[4,1]],FeynArts`Mass[FeynArts`V[_[Generic,5]]]];
            If[massPosition=!={},
               (*Get numbers of zero mass vector boson.*)
               massesOfVector = Flatten[List@@currentAmplitude[[4,2,All,Part[massPosition,1]]]];
               Sow[numbersOfAmplitudes[[i]]->Array[If[massesOfVector[[#]]=!=0,#,(##&)[]]&,Length@massesOfVector]];,
               (*Else zero replacement rule.*)
               Sow[numbersOfAmplitudes[[i]]->All];
            ];
         ,{i,Length@numbersOfAmplitudes}]
      ][[2,1]];
      (* Step 3: Change amplitudes. *)
      Do[
         numAmp = Part[numbersOfAmplitudes,i];
         newAmplitudes[[numAmp,4,2]] = amplitudes[[numAmp,4,2]][[numAmp/.rulesForClassesToSave]];
      ,{i,Length@numbersOfAmplitudes}];
      (* Step 4: Delete class diagrams. *)
      Do[
         If[daPairs[[i,1]]===True,
            currentClasses = daPairs[[i,2]]/.rulesForClassesToSave;
            currentClasses = Array[Rule[{#,2},newDiagrams[[i,2,#,2]][[Part[currentClasses,#]]]]&,Length@currentClasses];
            newDiagrams[[i,2]] = ReplacePart[diagrams[[i,2]],currentClasses];
         ];
      ,{i,Length@daPairs}];
      printDiagramsInfo[newDiagrams,"modifying amplitudes"];
   ];
   {newDiagrams,newAmplitudes}
];
getModifiedDA[x___] :=
Utils`AssertOrQuit[False,getModifiedDA::errUnknownInput,{x}];
SetAttributes[getModifiedDA,{Protected,Locked}];

getTopologyAmplitudeRulesByTopologyCriterion::usage=
"@brief Gives numbers of amplitudes which are accepted by a criterion on topology.
@param <TopologyList> diagrams Set of diagrams to select from.
@param <one argument function> critFunction Function for topology selection. If 
critFunction[<topology>] gives True, then topology is accepted.
@returns {<Rule>} List of rules of the form <boolean>->{<integer>..}. LHS
stands for the topology, RHS gives numbers of classes (and the numbers of
amplitudes the same time).";
getTopologyAmplitudeRulesByTopologyCriterion::errResult=
"Output
`1`
does not match desired pattern.

Input values
`2`
`3`";
getTopologyAmplitudeRulesByTopologyCriterion::errUnknownInput=
"Input should be
getTopologyAmplitudeRulesByTopologyCriterion@@{ <TopologyList>, <one argument function> }
and not
getTopologyAmplitudeRulesByTopologyCriterion@@`1`";
getTopologyAmplitudeRulesByTopologyCriterion[
   diagrams:FeynArts`TopologyList[__][Rule[FeynArts`Topology[_][__],_]..],
   critFunction_
] :=
Module[
   {
      topologies = List@@First/@diagrams,
      genNums = Length/@(List@@Last/@diagrams),
      numRegions,takeOrNot,res
   },
   numRegions = Array[Range[Plus@@genNums[[1;;#-1]]+1,Plus@@genNums[[1;;#]]]&,Length@genNums];
   takeOrNot = Array[TrueQ@critFunction@Part[topologies,#]&,Length@topologies];
   res = MapThread[#1->#2&,{takeOrNot,numRegions}];
   If[MatchQ[res, {Rule[_?(# === True || # === False &), {__Integer}] ..}],
      res,
      Utils`AssertOrQuit[False,getTopologyAmplitudeRulesByTopologyCriterion::errResult,res,Unevaluated@diagrams,Unevaluated@critFunction];
   ]
];
getTopologyAmplitudeRulesByTopologyCriterion[x___] :=
Utils`AssertOrQuit[False,getTopologyAmplitudeRulesByTopologyCriterion::errUnknownInput,{x}];
SetAttributes[getTopologyAmplitudeRulesByTopologyCriterion,{Protected,Locked,HoldAll,ReadProtected}];

topologyReplacements::usage =
"@brief List of topology replacement rules for a processes to hold.";
topologyReplacements =
{
   ExceptIrreducible -> (FreeQ[#,FeynArts`Internal]&), (*@todo something weird with this definition*)
   ExceptTriangles -> (FreeQ[FeynArts`ToTree@#,FeynArts`Centre@Except@3]&),
   ExceptBoxes -> (FreeQ[#,FeynArts`Vertex@4]&&FreeQ[FeynArts`ToTree@#,FeynArts`Centre@Except@4]&),
   ExceptFourFermionScalarPenguins -> (amITPinguin@#&),
   ExceptFourFermionMassiveVectorPenguins -> (amITPinguin@#&)
};
SetAttributes[topologyReplacements,{Protected,Locked}];

getExcludedTopologies::usage =
"@brief Joins names of processes to hold into one functions, creates unique 
name for it, then registers it for FeynArts` and returns the name.
@param <{Symbol...} | Symbol> name(s) of processes to hold.
@returns <Symbol> generated name of topologies to hold.";
getExcludedTopologies::errUnknownInput =
"Input should be
getExcludedTopologies@@{ <{Symbol...} | Symbol> }
and not
getExcludedTopologies@@`1`";
getExcludedTopologies[{}] :=
{};
getExcludedTopologies[{sym_Symbol}] :=
getExcludedTopologies@sym;
getExcludedTopologies[syms:{__Symbol}] :=
Module[{excludeTopologyName},
   FeynArts`$ExcludeTopologies[excludeTopologyName] =
      (Or @@ Through[(syms/.topologyReplacements)@#])&;
   excludeTopologyName];
getExcludedTopologies[sym_Symbol] :=
Module[{excludeTopologyName},
   FeynArts`$ExcludeTopologies[excludeTopologyName] = sym/.topologyReplacements;
   excludeTopologyName];
getExcludedTopologies[x___] :=
Utils`AssertOrQuit[False,getExcludedTopologies::errUnknownInput,{x}];
SetAttributes[getExcludedTopologies,{Protected,Locked}];

amITPinguin::usage =
"@brief If given topology is pinguin-like (mainly, for CLFV processes), then 
returns True, False otherwise.
@param <FeynArts`Topology[_][__]> topology to check.
@returns <boolean> If given topology is pinguin-like (mainly, for CLFV processes), then 
returns True, False otherwise.";
amITPinguin::errUnknownInput =
"Input should be
amITPinguin@@{ <FeynArts`.`Topology[_][__]> }
and not
amITPinguin@@`1`";
amITPinguin[topology:FeynArts`Topology[_][__]] :=
Module[
   {
      (*@note During creation of topologies we have External only.*)
      ext = FeynArts`External|FeynArts`Incoming|FeynArts`Outgoing,
      int = FeynArts`Internal,
      extFields,vert
   },
   extFields = Cases[topology, _[ext][__]];
   If[UnsameQ[Length@extFields,4],Return@False];
   If[!FreeQ[extFields,FeynArts`Vertex@4],Return@False];
   (*Only t-channel.*)
   If[!MatchQ[SortBy[topology,{Head@First@#&,First@First@#&}],
         _[_][
            _,_[ext][_[1][2],vert_,___],
            _,_[ext][_[1][4],vert_,___],
            ___,_[int][___,vert_,__],___
         ]
      ],
      Return@False];
   (*Rule for triangle.*)
   If[FreeQ[FeynArts`ToTree@topology,FeynArts`Centre@Except@3],Return@True];
   (*@note ,___ in the very end is for the stage when Field can appear.*)
   (*Rule for SE-like.*)
   SameQ[Length@Cases[FeynArts`ToTree@topology,_[ext][_,FeynArts`Centre[2][_],___]],1]
];
amITPinguin[x___] :=
Utils`AssertOrQuit[False,amITPinguin::errUnknownInput,{x}];
SetAttributes[amITPinguin,{Protected,Locked}];

getModifiedDiagrams::usage = 
"@brief Modifies diagrams according to excudeProcess list.
@param <TopologyList> set of topology-insertion rules to modify.
@param <List> set of names which specify the process to consider.
@returns <TopologyList> modified set of diagrams.";
getModifiedDiagrams::errUnknownInput =
"Input should be
getModifiedDiagrams@@{ <TopologyList>, <List> }
and not
getModifiedDiagrams@@`1`";
getModifiedDiagrams[
   inserted:FeynArts`TopologyList[_][Rule[FeynArts`Topology[_][__],FeynArts`Insertions[Generic][__]]..],
   excludeProcesses_
] :=
getModifiedDiagrams[inserted,{excludeProcesses}];
getModifiedDiagrams[
   inserted:FeynArts`TopologyList[_][Rule[FeynArts`Topology[_][__],FeynArts`Insertions[Generic][__]]..],
   excludeProcesses:{___}] :=
Module[
   {
   },
   If[Not[MemberQ[excludeProcesses,ExceptFourFermionScalarPenguins]&&
          MemberQ[excludeProcesses,ExceptFourFermionMassiveVectorPenguins]],
      If[MemberQ[excludeProcesses,ExceptFourFermionScalarPenguins],
         inserted = If[amITPinguin[#[[1]]],
         (*Delete vector fields on tree-level like propagator.*)
         #[[1]]->FeynArts`DiagramSelect[#[[2]],FreeQ[#,FeynArts`Field@5->FeynArts`V]&],
         (*Else do not touch.*)
         #]&/@ inserted;
         Print["MD: penguins: stu propagation of vector bosons is excluded"];
         printDiagramsInfo[inserted,"modifying diagrams"];
      ];
      If[MemberQ[excludeProcesses,ExceptFourFermionMassiveVectorPenguins],
         inserted = If[amITPinguin[#[[1]]],
         (*Delete scalar fields on tree-level like propagator.*)
         #[[1]]->FeynArts`DiagramSelect[#[[2]],FreeQ[#,FeynArts`Field@5->FeynArts`S]&],
         (*Else do not touch.*)
         #]&/@ inserted;
         Print["MD: penguins: stu propagation of scalars bosons is excluded"];
         printDiagramsInfo[inserted,"modifying diagrams"];
      ];
   ];
   inserted
];
getModifiedDiagrams[x___] :=
Utils`AssertOrQuit[False,getModifiedDiagrams::errUnknownInput,{x}];
SetAttributes[getModifiedDiagrams,{Protected,Locked}];

printDiagramsInfo[
   diagrams:FeynArts`TopologyList[_][Rule[FeynArts`Topology[_][__],FeynArts`Insertions[Generic][__]]..],
   where_String:"new"
] :=
Module[
   {
      nGeneric = Length@Cases[diagrams,Generic==_Integer:>1,Infinity,Heads -> True],
      nClasses = Length@Cases[diagrams,FeynArts`Classes==_Integer:>1,Infinity,Heads -> True]
   },
   Print[where,": in total: ",nGeneric," Generic, ",nClasses," Classes insertions"];
];
printAmplitudesInfo[
   amplitudes:FeynArts`FeynAmpList[__][FeynArts`FeynAmp[__,{__}->FeynArts`Insertions[FeynArts`Classes][{__}..]]..],
   where_String:"new"
] :=
Module[
   {
      nGeneric = Length@amplitudes,
      nClasses = Plus@@(Length[#[[4,2]]]&/@amplitudes)
   },
   Print[where,": in total: ",nGeneric," Generic, ",nClasses," Classes amplitudes"];
];
debugMakePictures[
   diagrams:FeynArts`TopologyList[_][Rule[FeynArts`Topology[_][__],FeynArts`Insertions[Generic][__]]..],
   name_String:"classes"
] :=
Module[
   {},
   DeleteFile[FileNames[FileNameJoin@{feynArtsDir, name<>"*"}]];
   Export[FileNameJoin@{feynArtsDir,name<>".png"},FeynArts`Paint[diagrams,
      FeynArts`PaintLevel->{FeynArts`Classes},
      FeynArts`SheetHeader->name,
      FeynArts`Numbering->FeynArts`Simple]]; 
];

GenericInsertionsForDiagram::usage=
"@brief applies FindGenericInsertions[] to a 
(Topology[_]->Insertions[Generic][__]) rule.
@returns list (for a given topology) of list (for all generic fields)
of list (for all class fields) of rules {{{x->y,..},..},..}
@param 1st argument is of the form Topology[_]->Insertions[Generic][__]
from FeynArts TopologyList[__][Topology[_]->Insertions[Generic][__],___]
@param 2nd argument changes the type of output field names
@note all indices in rhs. of rules are removed";
GenericInsertionsForDiagram[_->insertGen_, keepFieldNum_:False]:=
Map[FindGenericInsertions[#,keepFieldNum]&, Apply[List,insertGen,{0,1}]];

FindGenericInsertions::usage=
"@brief generic FeynmanGraph has rules Field[num]->particleType, 
class FeynmanGraph has rules Field[num]->particleClass. 
This function gives pairs particleType[gen,num]->particleClass, avoiding 
Field[_] mediator (if keepFieldNum==True then Field[_]->particleClass is given) 
@param 1st argument is of the form 
{FeynmanGraph[__][__],Insertions[Classes][__]}
@param 2nd argument changes the type of output field names
True gives Field[_] names, False gives particleClass names
@returns list (sorted; for all generic fields) of list (for all class fields) 
of rules {{x->y,..},..}
@note this function is called by GenericInsertionsForDiagram[]
@note this function doesn't look at external particles
@note all indices in rhs. of rules are removed";
FindGenericInsertions[{graphGen_,insertCl_}, keepFieldNum_]:=
Module[
   {
      toGenericIndexConventionRules = Cases[graphGen, 
         Rule[FeynArts`Field[index_Integer],type_Symbol] :>
         Rule[FeynArts`Field@index, type[FeynArts`Index[Generic,index]]]
      ], 
      fieldsGen, genericInsertions
   },
   fieldsGen = toGenericIndexConventionRules[[All,1]];
   genericInsertions = Cases[#, 
      Rule[genericField_,classesField_] /; MemberQ[fieldsGen, genericField] :>
      Rule[genericField, StripParticleIndices@classesField]] &/@ insertCl;
   SortBy[#,First]&/@ If[keepFieldNum,
      List @@ genericInsertions,
      List @@ genericInsertions /. toGenericIndexConventionRules
   ]
];

StripParticleIndices::usage=
"@brief Remove particle indices from a given (possibley generic) field
@param field the given field
@returns the given field with all indices removed";
StripParticleIndices[Times[-1,field_]] := 
   Times[-1, StripParticleIndices[field]];
StripParticleIndices[genericType_[classIndex_, ___]] := 
   genericType[classIndex];

ColourFactorForDiagram::usage=
"@brief acts on a (Topology[_]->Insertions[Generic][__]) rule.
creates adjacency matrix and field array for this topology and uses this
information for creation of colour factors for a given topology 
@param diagram (Topology[_]->Insertions[Generic][__]) rule
@returns list (for a given topology) of lists (for all generic fields) of 
(potentially) colour factors
@note during generation of genericDiagram at 1-loop level the ii-type loop
propagators have the largest number because of FeynArts
@note in seqProp numbers of the first vertices inside propagators are sorted
by FeynArts
@note external fields always come at first places in adjacency matrix
@note this function doesn't know anything about CXXDiagrams`.` context";
ColourFactorForDiagram[
   diagram:(_[_][seqProp__]->_[_][_[__][rulesFields__]->_,___])] :=
Module[
   {
      propPatt,adjacencyMatrix,externalRules,genericDiagram,genericInsertions
   },
   propPatt[i_, j_, f_] := _[_][_[_][i], _[_][j], f];
   
   adjacencyMatrix = Module[
      {adjs = Tally[{seqProp}/.propPatt[i_,j_,_]:>{{i,j},{j,i}}] },
      Normal@SparseArray@Flatten[{#[[1,1]]->#[[2]],#[[1,2]]->#[[2]]} &/@ adjs]];
      
   externalRules = Cases[{rulesFields}, HoldPattern[_[_]->_Symbol[__]]];
   
   genericDiagram = Module[
      {fld = Flatten[{seqProp}/.propPatt[i_,j_,f_]:>{{j,i,-f},{i,j,f}}, 1] },
      GatherBy[SortBy[fld,First],First] /. {_Integer, _Integer, f_} :> f
      ] /. Join[ {#} -> # &/@ externalRules[[All, 1]]];
      
   genericInsertions = GenericInsertionsForDiagram[diagram,True];
   
   Map[CXXDiagrams`ColourFactorForIndexedDiagramFromGraph[
      CXXDiagrams`IndexDiagramFromGraph[
         genericDiagram /. externalRules /. #, adjacencyMatrix],
      adjacencyMatrix] &,
      genericInsertions,
      {2}]
];

CalculateAmplitudes::usage=
"@brief Calculate a given set of amplitudes.
@param amps A set of class level amplitudes as generated by 
FeynArts`.`CreateFeynAmp[] (with colour indices removed)
form:
FeynAmpList[___][FeynAmp[
   GraphID[__],
   Integral[mom_],
   amp_,
   {whatIsInAmp___}->Insertion[Classes][{howToReplace___}..]]..]
@param <List> settingsForMomElim Sets up the MomElim option.
@param @todo.
@param genericInsertions the list of generic insertions for the amplitudes
@param regularizationScheme the regularization scheme for the calculation
@param zeroExternalMomenta True if external momenta should be set to zero and 
False otherwise
@returns a list of the format {fsAmplitudes, subexpressions} where 
fsAmplitudes denote the calculated amplitudes and subexpressions denote 
the subexpressions used to simplify the expressions";
CalculateAmplitudes[
   amps:FeynArts`FeynAmpList[___,FeynArts`Process->proc_,___][feynAmps:_[__]..],
   settingsForMomElim_List,
   settingsForGenericSums:{{Rule[_Integer,_]...}..},
   genericInsertions_List,
   regularizationScheme_,
   zeroExternalMomenta_,
   onShellFlag_] :=
Module[
   {
      combinatorialFactors = CombinatorialFactorsForClasses /@ {feynAmps},
      ampsGen = FeynArts`PickLevel[Generic][amps],
      numExtParticles = Plus@@Length/@proc,
      calculatedAmplitudes,abbreviations,subexpressions,
      zeroedRules
   },
   ampsGen = If[zeroExternalMomenta===True,
      FormCalc`OffShell[ampsGen, Sequence@@Array[#->0&,numExtParticles] ], (* Relations Mom[i]^2 = 0 are true now. *)
      ampsGen];
   Print["FORM calculation started ..."];
   calculatedAmplitudes = applyAndPrint[
      FormCalc`CalcFeynAmp[Head[ampsGen][#1],
         FormCalc`Dimension -> Switch[regularizationScheme,
            DimensionalReduction, 4,
            DimensionalRegularization, D],
         FormCalc`OnShell -> onShellFlag,
         FormCalc`FermionChains -> FormCalc`Chiral,
         FormCalc`FermionOrder -> None, (* FormCalc`Fierz leads to some cumbersome expressions. *)
         FormCalc`Invariants -> False,
         FormCalc`MomElim -> #2]&,
      {ampsGen,settingsForMomElim}] //. FormCalc`GenericList[];
   Print["FORM calculation done."];

   calculatedAmplitudes = MapThread[ToGenericSum,{calculatedAmplitudes,settingsForGenericSums}];
   
   abbreviations = identifySpinors[FormCalc`Abbr[] //. FormCalc`GenericList[],ampsGen];
   subexpressions = FormCalc`Subexpr[] //. FormCalc`GenericList[];

   If[zeroExternalMomenta,
      abbreviations = setZeroExternalMomentaInChains@abbreviations;
      zeroedRules = Cases[FormCalc`Abbr[],
         Rule[_,pair:FormCalc`Pair[FormCalc`k[_], FormCalc`k[_]]]
         :> (pair->0)];
      {abbreviations, zeroedRules} = ZeroRules[abbreviations, zeroedRules];
      {subexpressions, zeroedRules} = ZeroRules[subexpressions, zeroedRules];
      calculatedAmplitudes = calculatedAmplitudes /. zeroedRules;];

   FCAmplitudesToFSConvention[
      {calculatedAmplitudes, genericInsertions, combinatorialFactors},
      abbreviations, subexpressions]
];

setZeroExternalMomentaInChains::usage =
"@brief Sets FormCalc`k[i] to zero inside fermioinic chains.
@param abbreviations list of rules.
@returns Changed list of rules.";
setZeroExternalMomentaInChains::errUnknownInput =
"Input should be
setZeroExternalMomentaInChains@@{ <list of rules> }
and not
setZeroExternalMomentaInChains@@`1`";
setZeroExternalMomentaInChains[abbreviations:{Rule[_,_]...}] :=
Module[
   {
      replaceMomenta,temp,setZeroChainToZero
   },
   replaceMomenta[expr_] := expr/.FormCalc`k[_Integer]:>0;
   temp = abbreviations/.chain:FormCalc`DiracChain[__] :> replaceMomenta@chain;
   setZeroChainToZero[FormCalc`DiracChain[__,0,__]] := 0;
   setZeroChainToZero[chain:FormCalc`DiracChain[__]] := chain;
   temp/.chain:FormCalc`DiracChain[__] :> setZeroChainToZero@chain
]; 
setZeroExternalMomentaInChains[x___] := 
Utils`AssertOrQuit[False,setZeroExternalMomentaInChains::errUnknownInput,{x}];
SetAttributes[setZeroExternalMomentaInChains,{Protected,Locked}];

identifySpinors::usage =
"@brief Inserts the names of fermionic fields inside FormCalc`DicaChain structures.
@param inp List of abbreviations to modify | FormCalc`DiracChain chain to modify.
@param ampsGen FeynArts`FeynAmpList with information of process 
@returns DiracChain with inserted fermion names | Expression with new DiracChains.
@note DiracChains live only inside FormCalc`Abbr.
@note Should NOT be used for Automatic FormCalc`FermionOrder.";
identifySpinors::errUnknownInput =
"Input should be
identifySpinors@@{ <list of rules>, <feynamplist> } OR
identifySpinors@@{ <diracchain>, <feynamplist> }
and not
identifySpinors@@`1`";
identifySpinors[
   inp:{Rule[_,_]...},
   ampsGen:FeynArts`FeynAmpList[
      ___,
      (FeynArts`Process->Rule[{{__}..},{{__}..}]),
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]] := 
inp/.ch:FormCalc`DiracChain[__]:>identifySpinors[ch,ampsGen];
identifySpinors[
   FormCalc`DiracChain[
      FormCalc`Spinor[FormCalc`k[fermion1_Integer],mass1_,_Integer],
      seqOfElems___,
      FormCalc`Spinor[FormCalc`k[fermion2_Integer],mass2_,_Integer]],
   FeynArts`FeynAmpList[
      ___,
      process:(FeynArts`Process->Rule[{{__}..},{{__}..}]),
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]
] :=
Module[
   {
      identificationRules = getFermionPositionRules@process
   },
   FormCalc`DiracChain[
   FormCalc`Spinor[fermion1/.identificationRules,FormCalc`k[fermion1],mass1],
   seqOfElems,
   FormCalc`Spinor[fermion2/.identificationRules,FormCalc`k[fermion2],mass2]]
];
identifySpinors[x___] :=
Utils`AssertOrQuit[False,identifySpinors::errUnknownInput,{x}];
SetAttributes[identifySpinors,{Protected,Locked}];

getFermionPositionRules::usage =
"@brief Gives rules of the form number_of_input_field->name_of_fermion.
@param FeynArts`Process->Rule[_,_].
@returns Rules of the form number_of_input_field->name_of_fermion.";
getFermionPositionRules::errUnknownInput =
"Input should be
getFermionPositionRules@@{ FeynArts`Process->Rule[_,_] }
and not
getFermionPositionRules@@`1`";
getFermionPositionRules[
   FeynArts`Process->Rule[in:{{__}..},out:{{__}..}]
] :=
Module[
   {
      particleList = Join[in[[All,1]],out[[All,1]]],
      current
   },
   Flatten[ Reap[Do[
      Sow@Cases[{particleList[[current]]},fermion:FeynArts`F[__]:>(current->fermion),{1}];
      Sow@Cases[{particleList[[current]]},fermion:-FeynArts`F[__]:>(current->SARAH`bar[-fermion]),{1}];,
      {current,Length@particleList}]][[2]] ] //. fieldNameToFSRules
];
getFermionPositionRules[x___] :=
Utils`AssertOrQuit[False,getFermionPositionRules::errUnknownInput,{x}]
SetAttributes[getFermionPositionRules,{Protected,Locked}];

getNumberOfChains::usage =
"@brief Is used to calculate number of opened fermion chains.
@param FeynArts`FeynAmpList[..][..]
@returns Number of opened fermion chains.";
getNumberOfChains::errNumberOfFermions =
"During evaluation unexpected value of fermions `1` was calculated.";
getNumberOfChains::errUnknownInput =
"Input should be
getNumberOfExternalFermions@@{ FeynArts`FeynAmpList[___][___] }
and not
getNumberOfExternalFermions@@`1`";
getNumberOfChains[
   FeynArts`FeynAmpList[
      ___,
      FeynArts`Process->Rule[in:{{__}..},out:{{__}..}],
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]
] :=
Module[{numberOfChains = 0},
   Cases[Join[in[[All,1]],out[[All,1]]],FeynArts`F[__]|-FeynArts`F[__]:>numberOfChains++,{1}];
   numberOfChains /= 2;
   If[IntegerQ@numberOfChains && numberOfChains >= 0,
      numberOfChains,
      Utils`AssertOrQuit[False,getNumberOfChains::errNumberOfFermions,numberOfChains]
   ]
];
getNumberOfChains[x___] :=
Utils`AssertOrQuit[False,getNumberOfChains::errUnknownInput,{x}]
SetAttributes[getNumberOfChains,{Protected,Locked}];

applyAndPrint[func_,{expr_,opts_List},defLength_Integer:70] :=
Module[
   {
      now,
      totL = Length@expr,
      write,
      percent,
      numOfEq,
      restL
   },
   restL=defLength-2*IntegerLength@totL-11;
   write[args__] := Write[OutputStream["stdout", 1],args];
   Reap[
      Do[
      percent = now/totL;
      numOfEq = If[#<0,0,#]&[ Floor[percent*restL]-1 ];
      write[StringJoin[
         "[",StringJoin@@Array[" "&,IntegerLength@totL-IntegerLength@now],ToString@now,"/",ToString@totL,"]"," ",
         "[",StringJoin@@Array["="&,numOfEq],">",StringJoin@@Array[" "&,restL-numOfEq-1],"] ",ToString@Floor[100*percent],"%"]];
      Sow@func[ expr[[now]], opts[[now]] ];,
      {now,totL}]
   ][[2,1]]
];

CombinatorialFactorsForClasses::usage=
"@brief takes generic amplitude and finds numerical combinatirical factors
which arise at class level
@returns list of combinatorical factors for a given generic amplitude
@param FeynArts`.`FeynAmp[__]";
CombinatorialFactorsForClasses[
   FeynArts`FeynAmp[_,_,_,rules_->_[_][classReplacements__]]
]:=
Module[{position = Position[rules, FeynArts`RelativeCF]},
   {classReplacements}[[ All,position[[1,1]] ]] /. FeynArts`SumOver[__] -> 1
];

ToGenericSum::usage=
"@todo
@brief Given a generic amplitude, determine the generic fields over which it
needs to be summed and return a corresponding GenericSum[] object.
@param FormCalc`Amp[_->_][amp_] the given generic amplitude
@returns {S|F|V|U|T[GenericIndex[number of index]]...}.";
ToGenericSum[FormCalc`Amp[_->_][amp_],genericSumRestictions:{Rule[_Integer,_]...}] :=
Module[
   {
      sortSumFields = Sort@DeleteDuplicates[Cases[amp,
         _?(FAFieldQ)[FeynArts`Index[Generic,_Integer]],
         Infinity]],
      replSumFields
   },
   replSumFields = sortSumFields /. f_[_[_,i_]]:>{f@GenericIndex@i,Replace[i,genericSumRestictions~Join~{_Integer->False}]};
   GenericSum[amp, replSumFields]
];
SetAttributes[ToGenericSum,{Protected,Locked}];

FAFieldQ::usage=
"@brief Checks whether symbol belongs to FeynArts` field names or not.
@param Symbol to check.
@returns True if symbol belongs to FeynArts` field names, False otherwise.";
FAFieldQ = 
   MemberQ[{FeynArts`S,FeynArts`F,FeynArts`V,FeynArts`U,FeynArts`T},#]&;
SetAttributes[FAFieldQ,{Protected,Locked}];

ZeroRules::usage=
"@brief Given a set of rules that map to zero and a set that does
not map to zero, apply the zero rules to the non-zero ones
recursively until the non-zero rules do not change anymore.
@param nonzeroRules the list of nonzero rules
@param zeroRules the list of zero rules
@returns a list of rules that map the same expressions as the initial rules.
The return value is of the form {{Rule[_,_]...},{Rule[_,0]...}}";
ZeroRules[nonzeroRules:{Rule[_,_]...}, zeroRules:{Rule[_,0]...}] :=
Module[{newNonzero, newZeroRules},
   newNonzero = Thread[
      Rule[nonzeroRules[[All,1]],nonzeroRules[[All,2]] /. zeroRules]];

   If[newNonzero === nonzeroRules, Return[{nonzeroRules, zeroRules}]];

   newZeroRules = Cases[newNonzero,HoldPattern[_->0]];
   newNonzero = Complement[newNonzero, newZeroRules];

   ZeroRules[newNonzero, Join[zeroRules,newZeroRules]]
];

FCAmplitudesToFSConvention::usage=
"@brief Tranlate a list of FormCalc amplitudes and their abbreviations and
subexpressions into FlexibleSUSY language.
@param amplitudes the given list of amplitudes
@param abbreviations list of abbreviations
@param aubexpressions list of subexpressions
@returns a list of the form
`{fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}`
where all FlexibleSUSY conventions have been applied.";
FCAmplitudesToFSConvention[amplitudes_, abbreviations_, subexpressions_] :=
Module[{fsAmplitudes, fsAbbreviations, fsSubexpressions},
   fsAmplitudes = amplitudes //. amplitudeToFSRules;
   fsAbbreviations = abbreviations //. subexpressionToFSRules;
   fsSubexpressions = subexpressions //. subexpressionToFSRules;
   {fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}
];

SetAttributes[
   {
   SetFSConventionRules,
   NPointFunctionFAFC,
   GenericInsertionsForDiagram,FindGenericInsertions,StripParticleIndices,
   ColourFactorForDiagram,
   CombinatorialFactorsForClasses,
   ZeroRules,FCAmplitudesToFSConvention
   }, 
   {Protected, Locked}];

End[];
EndPackage[];
