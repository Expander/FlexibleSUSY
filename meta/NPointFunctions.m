(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

BeginPackage["NPointFunctions`",{"FlexibleSUSY`","SARAH`","CXXDiagrams`","Vertices`","Parameters`","Utils`"}];

LoopLevel::usage="An integer option given to NPointFunction[] that encodes the \
loop level at which to calculate amplitudes.";
Regularize::usage="An option given to NPointFunction[] that encodes the \
regularization scheme to be used.";
DimensionalReduction::usage="A possible value for the Regularize option";
DimensionalRegularization::usage="A possible value for the Regularize option";
ZeroExternalMomenta::usage="An boolean option given to NPointFunction[] that \
encodes whether to set the external momenta to zero or leave them undetermined.";
LoopFunctions::usage="Option that controls whether to use FlexibleSUSY or LoopTools for loop functions.";
UseCache::usage="Option to cache and reuse the expressions generated by FeynArts/FormCalc";
ExcludedTopologies::usage="Option to exclude specific topologies in FeynArts";
OneParticleReducible::usage="Possible value for ExcludedTopologies.";

NPointFunction::usage="Calculate the n-point correlation function for a set of \
incoming and a set of outgoing fields.";
VerticesForNPointFunction::usage="Return a list of all vertices needed to calculate \
a given n-point correlation function.";
CreateCXXFunctions::usage="Create the c++ code for a given set of n-point \
correlation functions.";
CreateCXXHeaders::usage="Create the c++ code for the necessary headers for evaluation \
of n-point correlation functions.";

A0i::usage="A symbol representing an A0 function.";
B0i::usage="A symbol representing an B0 function.";
C0i::usage="A symbol representing an C0 function.";
D0i::usage="A symbol representing an D0 function.";

aa0::usage="A symbol denoting a part of an A function.";

bb0::usage="A symbol denoting a part of a B function.";
bb1::usage="A symbol denoting a part of a B function.";

cc0::usage="A symbol denoting a part of a C function.";
cc1::usage="A symbol denoting a part of a C function.";
cc2::usage="A symbol denoting a part of a C function.";

dd0::usage="A symbol denoting a part of a D function.";
dd1::usage="A symbol denoting a part of a D function.";
dd2::usage="A symbol denoting a part of a D function.";
dd3::usage="A symbol denoting a part of a D function.";

GenericS::usage="A symbol that acts as a placeholder for any scalar field.";
GenericF::usage="A symbol that acts as a placeholder for any fermion field.";
GenericV::usage="A symbol that acts as a placeholder for any vector field.";
GenericU::usage="A symbol that acts as a placeholder for any ghost field.";
GenericT::usage="A symbol that acts as a placeholder for any tensor field.";

GenericSum::usage="Represent a sum over a set of generic fields.";
GenericIndex::usage="Represent an index of a generic field.";

LorentzIndex::usage="Represent a Lorentz index of a generic field.";

Begin["`Private`"];

(** \brief Return the SARAH model name as to be passed to
 * ``SARAH`Start[]``.
 * \returns the SARAH model name as to be passed to
 * ``SARAH`Start[]``.
 **)
SARAHModelName[] := If[SARAH`submodeldir =!= False,
                       SARAH`modelDir <> "-" <> SARAH`submodeldir,
                       SARAH`modelDir]
                       
(** \brief Return the model name that is used by SARAH to name the
 * FeynArts model file it creates.
 * \returns the model name that is used by SARAH to name the
 * FeynArts model file it creates.
 **)
ClassesModelFileName[] := SARAH`ModelName <> ToString[FlexibleSUSY`FSEigenstates]

(** \brief Return the model name that is used by SARAH to name the
 * FeynArts substitution file it creates.
 * \returns the model name that is used by SARAH to name the
 * FeynArts substitution file it creates.
 **)
SubstitutionsFileName[] :=
  "Substitutions-" <> SARAH`ModelName <>
  ToString[FlexibleSUSY`FSEigenstates] <> ".m"

(** \brief Calculate the n-point correlation function for a set of
 * incoming and a set of outgoing fields.
 * \param inFields a list of incoming fields
 * \param outFields a list of outgoing fields
 * \param LoopLevel the loop level at which to perform the calculation
 * \param Regularize the regularization scheme to apply
 * \param UseCache whether to attempt to read and write the result
 * from and to the cache.
 * \param ZeroExternalMomenta whether to set the external momenta to
 * zero or leave them undetermined.
 * \param ExcludedTopologies a list or single symbol of topologies to
 * exclude when calculation the n-point correlation function
 * \returns the corresponding n-point correlation function
 * \note only a loop level of 1 is currently supported
 * \note the recognized regularization schemes are:
 * - DimensionalReduction
 * - DimensionalRegularization
 * \note when not setting the external momenta to zero you should use
 * LoopTools for the evaluation of the loop functions.
 **)
NPointFunction[inFields_List,outFields_List,
    OptionsPattern[{LoopLevel -> 1,
                    Regularize -> Switch[FlexibleSUSY`FSRenormalizationScheme,
                      FlexibleSUSY`DRbar, DimensionalReduction,
                      FlexibleSUSY`MSbar, DimensionalRegularization],
                    UseCache -> True, ZeroExternalMomenta -> False,
                    ExcludedTopologies -> {}}]]:=
  Module[{loopLevel, zeroExternalMomenta, regularizationScheme, nPointMeta,
          useCache, excludedTopologies,
          sarahOutputDir = SARAH`$sarahCurrentOutputMainDir,
          fsMetaDir = $flexiblesusyMetaDir,
          outputDir,
          currentPath, currentDirectory,
          feynArtsDir,formCalcDir,nPointFunctionsDir,
          cachedNPointFunction,
          feynArtsModel,substitutionsFile,particleNamesFile,
          inFANames,outFANames,
          subKernel,calculationCommand,particleNamespaceFile,
          fileHandle,nPointFunction},
    loopLevel = OptionValue[LoopLevel];
    Utils`AssertWithMessage[loopLevel === 1,
			"NPointFunctions`NPointFunction[]: Only loop level 1 is supported"];
		
    regularizationScheme = OptionValue[Regularize];
    Utils`AssertWithMessage[
			regularizationScheme === DimensionalReduction ||
      regularizationScheme === DimensionalRegularization,
			"NPointFunctions`NPointFunction[]: Unknown regularization scheme: " <>
			ToString[regularizationScheme]];
		
    zeroExternalMomenta = OptionValue[ZeroExternalMomenta];
    Utils`AssertWithMessage[zeroExternalMomenta === True || zeroExternalMomenta === False,
			"NPointFunctions`NPointFunction[]: Option ZeroExternalMomenta must \
be either True or False"];

    useCache = OptionValue[UseCache];
    Utils`AssertWithMessage[useCache === True || useCache === False,
            "NPointFunctions`NPointFunctions[]: Option UseCache must be either \
            True or False."];

    excludedTopologies = OptionValue[ExcludedTopologies];

    Utils`AssertWithMessage[And @@
			TreeMasses`IsScalar /@ Join[inFields, outFields],
			"NPointFunctions`NPointFunction[]: Only external scalars are \
supported (for now)."];

    inFields = Vertices`StripFieldIndices[inFields];
    outFields = Vertices`StripFieldIndices[outFields];
    nPointMeta = {loopLevel, regularizationScheme, zeroExternalMomenta};

    outputDir = FileNameJoin[{sarahOutputDir, ToString[FlexibleSUSY`FSEigenstates]}];

    nPointFunctionsDir = FileNameJoin[{outputDir, "NPointFunctions"}];
    If[DirectoryQ[nPointFunctionsDir] == False,
       CreateDirectory[nPointFunctionsDir]];

    nPointFunctionFile = FileNameJoin[{nPointFunctionsDir, "temp"}];

    If[useCache === True,
        nPointFunction = CachedNPointFunction[
            inFields, outFields, nPointMeta];
        If[nPointFunction =!= Null,
            Return[nPointFunction]]
    ];

    feynArtsDir = FileNameJoin[{outputDir, "FeynArts"}];
    formCalcDir = FileNameJoin[{outputDir, "FormCalc"}];
    
    feynArtsModel = FileNameJoin[{feynArtsDir, ClassesModelFileName[]}];
    particleNamesFile = FileNameJoin[{feynArtsDir, "ParticleNamesFeynArts.dat"}];
    particleNamespaceFile = FileNameJoin[{feynArtsDir, "ParticleNamespaces.m"}];
    substitutionsFile = FileNameJoin[{feynArtsDir, SubstitutionsFileName[]}];
    
    subKernels = LaunchKernels[2];

    If[FileExistsQ[feynArtsModel <> ".mod"] === False,
       GenerateFAModelFileOnKernel[subKernels[[1]]];
       WriteParticleNamespaceFile[particleNamespaceFile]];

    inFANames = FeynArtsNamesForFields[inFields, particleNamesFile];
    outFANames = FeynArtsNamesForFields[outFields, particleNamesFile];
    
    currentPath = $Path;
    currentDirectory = Directory[];

    (* Unfortunately, there seems to be no way to restrict
      this to a specific kernel *)
    DistributeDefinitions[currentPath, currentDirectory,
      fsMetaDir, feynArtsDir, formCalcDir, feynArtsModel,
      particleNamesFile, substitutionsFile, particleNamespaceFile,
      inFANames, outFANames,
      loopLevel, regularizationScheme, zeroExternalMomenta, excludedTopologies];

    nPointFunction = ParallelEvaluate[
      $Path = currentPath;
      SetDirectory[currentDirectory];
      
      Get[FileNameJoin[{fsMetaDir, "NPointFunctions", "internal.m"}]];
      
      NPointFunctions`SetFAFCPaths[
        feynArtsDir, formCalcDir, feynArtsModel,
        particleNamesFile, substitutionsFile,
        particleNamespaceFile];
      
      NPointFunctions`NPointFunctionFAFC[
        ToExpression[inFANames], ToExpression[outFANames],
        LoopLevel -> loopLevel,
        Regularize -> regularizationScheme,
        ZeroExternalMomenta -> zeroExternalMomenta,
        ExcludedTopologies -> excludedTopologies],
      subKernels[[2]]];
    
    CloseKernels[subKernels];
    
    Utils`AssertWithMessage[nPointFunction =!= $Failed,
			"NPointFunctions`NPointFunction[]: Calculation failed"];
    
    If[useCache === True,
        CacheNPointFunction[nPointFunction, nPointMeta]];

    nPointFunction
  ]

(** \brief Generate the FeynArts model file on a given subkernel **)
GenerateFAModelFileOnKernel[kernel_] :=
  Module[{currentPath, currentDirectory,
          fsMetaDir = $flexiblesusyMetaDir,
          sarahInputDirectories, sarahOutputDirectory,
          sarahModelname, eigenstates},
    currentPath = $Path;
    currentDirectory = Directory[];
    sarahInputDirectories = SARAH`SARAH[InputDirectories];
    sarahOutputDirectory = SARAH`SARAH[OutputDirectory];
    sarahModelName = SARAHModelName[];
    eigenstates = FlexibleSUSY`FSEigenstates;
    
    (* Unfortunately, there seems to be no way to restrict
      this to a specific kernel *)
    DistributeDefinitions[currentPath, currentDirectory,
      fsMetaDir, sarahInputDirectories, sarahOutputDirectory,
      sarahModelName, eigenstates];
    
    ParallelEvaluate[
      $Path = currentPath;
      SetDirectory[currentDirectory];
      
      Get[FileNameJoin[{fsMetaDir, "NPointFunctions", "createFAModelFile.m"}]];
      
      NPointFunctions`CreateFAModelFile[sarahInputDirectories,
				sarahOutputDirectory, sarahModelName, eigenstates],
      kernel];
  ]

(** \brief Write a file containing all field names and the contexts
 * in which they live in Mathematica
 * \note This is necessary because SARAH puts fields into different
 * contexts.
 **)
WriteParticleNamespaceFile[fileName_String] :=
  Module[{fileHandle = OpenWrite[fileName]},
    Write[fileHandle, {ToString[#], Context[#]} &
      /@ TreeMasses`GetParticles[]];
    Close[fileHandle];
  ]

(** \brief Return a list of all vertices needed to calculate a given 
 * n-point correlation function.
 * \param nPointFunction the given n-point correlation function
 * \returns a list of all vertices needed to calculate a given 
 * n-point correlation function.
 **)
VerticesForNPointFunction[nPointFunction_] := 
  Module[{genericVertices, genericSumPositions,
          genericInsertions, vertices},
    genericVertices = DeleteDuplicates[Cases[nPointFunction,
      SARAH`Cp[fields___] :> {fields}, Infinity, Heads -> True]];

    genericSumPositions = Position[nPointFunction[[2,1,1]], GenericSum[__]];
    genericInsertions = DeleteDuplicates[
      Flatten @ Extract[nPointFunction[[2,1,2]], genericSumPositions]];

    vertices = UniquelyInstantiateGenericFields[genericVertices,
      GatherBy[genericInsertions, First]];
    Map[StripFieldIndices, vertices, {2}]
  ]

(** \brief given a list of expressions and a list of of generic field
 * insertions of the form ``{{r1 -> s11, r1 -> s12, ...}, {...}, ...}``
 * successively apply each of them so that all combinations
 * replacements are generated. Resulting duplicate expressions are
 * discarded.
 * \param exprs the list of expressions
 * \param fieldInsertions the list of insertions to be applied
 **) 
UniquelyInstantiateGenericFields[exprs_List, {}] := exprs
UniquelyInstantiateGenericFields[exprs_List, {fieldInsertions_List, next___}] :=
  Module[{nextExprs},
    nextExprs = Flatten[exprs /. (List /@ fieldInsertions), 1];
    UniquelyInstantiateGenericFields[DeleteDuplicates[nextExprs], {next}]
  ]

(** \brief Given a list of n-point correllation functions, a list
 * of c++ function names and a list of colour factor projections
 * create the c++ code for the numerical evaluation of the
 * n-point correllation functions.
 * \param nPointFunctions the list of n-point correlation functions
 * \param names the list of function names
 * \param colourFactorProjections a list or a singleton of colour factor
 * projections that shall be applied to the general expressions for the
 * colour factors in the corresponding n-point correllation function.
 * The result of applying such a projection must be a scalar. e.g
 * ``exampleProjection[scalar_ *
 *   SARAH`Delta[colourIndex1_, colourIndex2_]] :> scalar``
 * \param LoopFunctions the loop function library to be used.
 * \note Currently, only FlexibleSUSY and LoopTools are supported as
 * loop function libraries.
 * \returns a list of the form `{prototypes, definitions}` containing
 * the corresponding c++ code.
 **)
CreateCXXFunctions[nPointFunctions_List, names_List,
    colourFactorProjections_,
    OptionsPattern[{LoopFunctions -> "FlexibleSUSY"}]] :=
  Module[{loopFunctionRules, hasExternalMomenta, prototypes,
          definitionHeads, definitionBodies,
          auxilliaryClasses, definitions},
    loopFunctionRules = Switch[OptionValue[LoopFunctions],
      "LoopTools", {},
      "FlexibleSUSY",
         Print["Warning: Using FlexibleSUSY loop functions will only remap A0, B0, C0 and D0."];
         Print["Warning: FlexibleSUSY loop functions C0 and D0 require zero external momenta."];
         {
           LoopTools`A0i[LoopTools`aa0, args__] :> "softsusy::a0"[Sequence @@ ("std::sqrt" /@ List[args]),
                                             "context.scale()"],
           LoopTools`A0[arg_] :> "softsusy::a0"[Sequence @@ ("std::sqrt" /@ List[arg]),
                                             "context.scale()"],
           LoopTools`B0i[LoopTools`bb0, args__] :> "softsusy::b0"[Sequence @@ ("std::sqrt" /@ List[args]),
                                             "context.scale()"],
           LoopTools`C0i[LoopTools`cc0, 0, 0, 0, args__] :> "softsusy::c0"[Sequence @@ ("std::sqrt" /@ List[args])],
           LoopTools`D0i[LoopTools`dd0, 0, 0, 0, 0, 0, 0, args__] :> "softsusy::d0"[Sequence @@ ("std::sqrt" /@ List[args])]
         },
       _, Return["Option LoopFunctions must be either LoopTools or FlexibleSUSY"]];

    hasExternalMomenta =
      FreeQ[#, SARAH`Mom[_Integer, ___]] & /@ nPointFunctions;

    prototypes = StringJoin[Riffle[
      "std::complex<double> " <> #[[2]] <>
        CXXArgStringForNPointFunctionPrototype[#[[1]]] <> ";" & /@
      Transpose[{nPointFunctions, names}], "\n"]];
      
    definitionHeads = "std::complex<double> " <> #[[2]] <>
        CXXArgStringForNPointFunctionDefinition[#[[1]]] & /@
      Transpose[{nPointFunctions, names}];
      
    definitionBodies = CXXBodyForNPointFunction /@ nPointFunctions;
    auxilliaryClasses = CXXClassForNPointFunction[Sequence @@ #] & /@
      Transpose[{
        nPointFunctions /. loopFunctionRules,
        If[Head[colourFactorProjections] === List,
          colourFactorProjections,
          Table[colourFactorProjections, {Length[names]}]]
      }];

    definitions = StringJoin[Riffle[auxilliaryClasses,"\n\n"]] <> "\n\n" <>
      StringJoin[Riffle[#[[1]] <> "\n{\n" <> #[[2]] <> "\n}" & /@
         Transpose[{definitionHeads, definitionBodies}], "\n\n"]];

    {prototypes, definitions}
  ]

(** \brief Return the c++ arguments that the c++ version of the given
 * n-point correlation function shall take with the default value of
 * zero for all external momenta.
 * \param nPointFunction the given n-point correlation function
 * \returns the c++ arguments that the c++ version of the given
 * n-point correlation function shall take with the default value of
 * zero for all external momenta.
 **)
CXXArgStringForNPointFunctionPrototype[nPointFunction_] :=
  Module[{numberOfIndices, numberOfMomenta},
    numberOfIndices = Length[ExternalIndicesForNPointFunction[nPointFunction]];
    numberOfMomenta = If[FreeQ[nPointFunction, SARAH`Mom[_Integer, ___]],
      0, Length[nPointFunction[[1,1]]] + Length[nPointFunction[[1,2]]]];

    "( const " <> FlexibleSUSY`FSModelName <> "_mass_eigenstates &model, " <>
       "const std::array<int, " <>
      ToString[numberOfIndices] <> "> &indices, const std::array<Eigen::Vector4d, " <>
      ToString[numberOfMomenta] <> "> &momenta = { " <>
        StringJoin[Riffle[Table["Eigen::Vector4d::Zero()", {k,numberOfMomenta}],
                          ", "]] <> " } )"
  ]

(** \brief Return the c++ arguments that the c++ version of the given
 * n-point correlation function shall take without default values for
 * the arguments.
 * \param nPointFunction the given n-point correlation function
 * \returns the c++ arguments that the c++ version of the given
 * n-point correlation function shall take without default values for
 * the arguments.
 **)
CXXArgStringForNPointFunctionDefinition[nPointFunction_] :=
  Module[{numberOfIndices, numberOfMomenta},
    numberOfIndices = Length[ExternalIndicesForNPointFunction[nPointFunction]];
    numberOfMomenta = If[FreeQ[nPointFunction, SARAH`Mom[_Integer, ___]],
      0, Length[nPointFunction[[1,1]]] + Length[nPointFunction[[1,2]]]];

    "( const " <> FlexibleSUSY`FSModelName <> "_mass_eigenstates &model, const std::array<int, " <>
      ToString[numberOfIndices] <> "> &indices, const std::array<Eigen::Vector4d, " <>
      ToString[numberOfMomenta] <> "> &momenta )"
  ]

(** \brief Return the c++ code for the function body of the c++
 * version of a given n-point correlation function.
 * \param nPointFunction the given n-point correlation function
 * \returns the c++ code for the function body of its c++
 * version.
 **)
CXXBodyForNPointFunction[nPointFunction_] :=
  Module[{className},
    CXXClassNameForNPointFunction[nPointFunction] <>
      " helper{ model, indices, momenta };\n" <>
    "return helper.calculate();"
  ]

(** \brief Return the c++ code for the helper class of the c++
 * version of a given n-point correlation function.
 * \param nPointFunction the given n-point correlation function
 * \param projectColourFactor the colour factor projection to be
 * applied for the given n-point correlation function
 * \returns the c++ code for the helper class of the c++
 * version of a given n-point correlation function.
 **)
CXXClassForNPointFunction[nPointFunction_, projectColourFactor_] :=
  Module[{className = CXXClassNameForNPointFunction[nPointFunction],
          externalIndices, cxxCorrelationContext,
          numberOfIndices, numberOfMomenta, genericSumPositions,
          genericIndices, genericFields, genericSumNames,
          genericSumCode, preCXXRules, cxxExpr,
          subexpressions, cxxSubexpressions},
    externalIndices = ExternalIndicesForNPointFunction[nPointFunction];
    numberOfIndices = Length[externalIndices];
    numberOfMomenta = If[FreeQ[nPointFunction, SARAH`Mom[_Integer, ___]],
      0, Length[nPointFunction[[1,1]]] + Length[nPointFunction[[1,2]]]];

    genericSumPositions = Position[nPointFunction[[2,1,1]], GenericSum[__]];
    genericIndices = DeleteDuplicates[Flatten[
      Extract[nPointFunction[[2,1,1]], genericSumPositions][[All,2]], 1]];
    genericFields = #[[1]][GenericIndex[#[[2]]]] & /@ genericIndices;
    genericSumNames = Table["genericSum" <> ToString[k],
                            {k,Length[genericSumPositions]}];

    subexpressions = nPointFunction[[2,2]];
    preCXXRules = ToCXXPreparationRules[
      externalIndices, genericFields, subexpressions];

    cxxSubexpressions = 
      CXXCodeForSubexpressions[subexpressions, preCXXRules];

    genericSumCode = StringJoin[Riffle[
      CXXCodeForGenericSum[Sequence @@ #, subexpressions, preCXXRules] & /@
        Transpose[{
          Extract[nPointFunction[[2,1,1]], genericSumPositions],
          Extract[nPointFunction[[2,1,2]], genericSumPositions],
          Extract[nPointFunction[[2,1,3]], genericSumPositions],
          projectColourFactor /@
            Extract[nPointFunction[[2,1,4]], genericSumPositions],
          genericSumNames}],
      "\n\n"]];

    cxxExpr = Plus @@ ReplacePart[nPointFunction[[2,1,1]],
      Rule @@@ Transpose[{genericSumPositions, # <> "()" & /@ genericSumNames}]];
    cxxExpr = Parameters`ExpressionToString[cxxExpr];
    cxxExpr = StringReplace[cxxExpr, "\"" -> ""];

    cxxCorrelationContext = "correlation_function_context<" <>
       ToString[numberOfIndices] <> ", " <> ToString[numberOfMomenta] <>
    ">";
    
    "class " <> className <> "\n" <>
    ": public " <> cxxCorrelationContext <> "\n{\n" <>
    "using generic_sum_base = " <> cxxCorrelationContext <> ";\n" <>
    "template<class GenericFieldMap> struct subexpression_base\n" <>
    ": generic_sum_base,\n" <>
    "  index_map_interface<GenericFieldMap>\n" <>
    "{\n" <> 
    "subexpression_base( const subexpression_base & ) = default;\n" <>
    "subexpression_base( const generic_sum_base &gsb, \n" <>
    "const typename field_index_map<GenericFieldMap>::type &fim )\n" <>
    ": generic_sum_base( gsb ), index_map_interface<GenericFieldMap>( fim )\n" <>
    "{}\n" <>
    "};\n\n" <>

    StringJoin[Riffle[
        "struct " <> CXXKeyOfGenericField[#] <> " {};" & /@ genericFields,
      "\n"]] <> "\n\n" <>

    cxxSubexpressions <> "\n\n" <> 
    genericSumCode <> "\n\n" <>
    "public:\n" <>
    className <> CXXArgStringForNPointFunctionDefinition[nPointFunction] <> "\n" <>
    ": " <> cxxCorrelationContext <> "{ model, indices, momenta }\n{}\n\n" <>
    
    "std::complex<double> calculate( void )\n{\nreturn " <>
    cxxExpr <>
    ";\n}" <>
    "\n};"
  ]

(** \brief Generate a list of rules for translating Mathematica
 * expressions of n-point correlation functions to c++ counterparts.
 * \param externalIndices the external indices of an n-point
 * correlation function
 * \param genericFields the generic fields appearing in an n-point
 * correlation function
 * \param subexpressions the list of subexpressions needed to evaluate
 * an n-point correlation function
 * \returns a list of rules for translating Mathematica
 * expressions of n-point correlation functions to c++ counterparts.
 **)
ToCXXPreparationRules[externalIndices_List, 
    genericFields_List, subexpressions_List] :=
  Module[{externalIndexRules, genericRules,
          subexprRules, massRules, couplingRules},
    externalIndexRules = Rule[#[[1]],
        "this->external_indices(" <> ToString[#[[2]]] <> ")"] & /@
      Transpose[{externalIndices, Table[k, {k, Length[externalIndices]}] - 1}];

    genericRules = Join[
      Rule[Susyno`LieGroups`conj[#], CXXNameOfGenericField[Susyno`LieGroups`conj[#]][
        CXXIndicesForField[#]]] & /@ genericFields,
      Rule[SARAH`bar[#], CXXNameOfGenericField[SARAH`bar[#]][
        CXXIndicesForField[#]]] & /@ genericFields,
      Rule[#, CXXNameOfGenericField[#][
        CXXIndicesForField[#]]] & /@ genericFields
    ];

    couplingRules = {
      SARAH`Cp[fields___][1] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
      ">( lorentz_scalar{}, concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <> 
      " ) )",
      SARAH`Cp[fields___][SARAH`PL] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
      ">( lorentz_left{}, concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <> 
      " ) )",
      SARAH`Cp[fields___][SARAH`PR] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
      ">( lorentz_right{}, concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <> 
      " ) )",
      SARAH`Cp[fields___][SARAH`Mom[f1_] - SARAH`Mom[f2_]] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
      ">( lorentz_momentum_diff{" <>
            ToString[Position[{fields},f1,{1},Heads->False][[1,1]]-1] <> ", " <>
            ToString[Position[{fields},f2,{1},Heads->False][[1,1]]-1] <> "}, " <>
        "concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <> 
      " ) )",
      SARAH`Cp[fields___][SARAH`g[_,_]] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
      ">( lorentz_inverse_metric{}, concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <> 
      " ) )"
    };
    massRules = SARAH`Mass[field_String[indices_String]] :>
      "context.mass<" <> field <> ">( " <> indices <> " )";
    subexprRules = Rule[#[[1]], ToString[#[[1]]] <> "_()"] & /@
      subexpressions;

    {externalIndexRules, couplingRules,
     genericRules, massRules, subexprRules}
  ]

(** \brief Create the c++ code encoding a given set of subexpressions.
 * \param subexpressions the list of subexpressions
 * \param preCXXRules a list of rules to apply to the subexpressions
 * before calling ``Parameters`ExpressionToString[]`` for the c++
 * translation.
 * \returns the c++ code encoding a given set of subexpressions.
 **)
CXXCodeForSubexpressions[subexpressions_List, preCXXRules_List] :=
  Module[{names = ToString /@ subexpressions[[All,1]],
          exprs = subexpressions[[All,2]], subexpr,
          relevantSubexpressions, relevantGenericFields,
          needsContexts, cxxExprs},
    relevantGenericFields = DeleteDuplicates /@
      (Cases[#,_[GenericIndex[_]], Infinity, Heads -> True] & /@ exprs);

    relevantSubexpressions = DeleteDuplicates /@
      (Cases[#,
        Pattern[subexpr, Alternatives @@ subexpressions[[All,1]]] :> subexpr,
          Infinity,
            Heads -> True] & /@ exprs);

    needsContexts = !(FreeQ[#, SARAH`Cp] && FreeQ[#, SARAH`Mass]) & /@ exprs;

    cxxExprs = Parameters`ExpressionToString[
      Fold[ReplaceAll, #, preCXXRules]] & /@ exprs;
    cxxExprs = StringReplace[#, "\"" -> ""] & /@ cxxExprs;

    StringJoin[Riffle[
    Module[{name = #[[1]], genericFields = #[[2]],
       subs = #[[3]], needsContext = #[[4]], cxxExpr = #[[5]]},
    "template<class GenericFieldMap> struct " <> name <>
    "\n: subexpression_base<GenericFieldMap>\n{\n" <>
    "template<class ...Args> " <> name <> "( Args &&...args )\n" <>
    ": subexpression_base<GenericFieldMap>( std::forward<Args>( args )... )\n{}\n\n" <>
    "std::complex<double> operator()( void ) const\n{\n" <>

    If[Length[subs] =!= 0,
      StringJoin[ToString[#] <> "<GenericFieldMap> " <>
        ToString[#] <> "_{ *this };\n" & /@
        subs] <> "\n",
      ""] <>

    If[Length[genericFields] =!= 0,
      "using boost::mpl::at;\n" <>
      "using boost::fusion::at_key;\n\n" <>

      StringJoin[Module[{genericField = #},
        "using " <> CXXNameOfGenericField[genericField] <>
        " = typename at<GenericFieldMap, " <>
          CXXKeyOfGenericField[genericField] <>
        ">::type;\n"
        ] & /@ genericFields] <> "\n" <>

      StringJoin[Module[{genericField = #},
        "const auto &" <> CXXIndicesForField[genericField] <>
        " = at_key<" <> CXXKeyOfGenericField[genericField] <>
          ">( this->index_map() );\n"
        ] & /@ genericFields] <> "\n",
      ""] <>

    If[needsContext,
       "const context_with_vertices &context =  *this;\n\n",
       ""] <>
    
    "return " <> cxxExpr <> ";\n}\n};"] & /@
      Transpose[{names, relevantGenericFields,
                 relevantSubexpressions, needsContexts, cxxExprs}],
    "\n\n"]]
  ]

(** \brief Create the c++ code encoding a given sum over generic fields.
 * \param sum the sum over generic fields
 * \param genericInsertions the list of field insertions to be summed
 * over
 * \param combinatorialFactors a list of combinatorial factors
 * (~symmetry factors) to multiply the amplitudes of specific insertions
 * with.
 * \param colourFactors a list of colour factors to multiply the
 * amplitudes of specific insertions with.
 * \param functionName the name of the resulting c++ function
 * \param subexpressions the list of subexpressions
 * \param preCXXRules a list of rules to apply to the subexpressions
 * before calling ``Parameters`ExpressionToString[]`` for the c++
 * translation.
 * \returns the c++ code encoding the given sum over generic fields.
 **)
CXXCodeForGenericSum[sum_GenericSum, genericInsertions_List,
    combinatorialFactors_List, colourFactors_List, functionName_String,
    subexpressions_List, preCXXRules_List] :=
  Module[{expr = sum[[1]], indices = sum[[2]],
          sortedGenericInsertions, genericFields, relevantSubexpressions,
          subexpr, needsContext, cxxExpr, ReRatioColourFactors, ImRatioColourFactors},
    Utils`AssertWithMessage[NumberQ[#],
      "CXXDiagrams`CXXCodeForGenericSum[]: Projected colour factor is
not a number: " <> ToString[#]] & /@ colourFactors;
    ReRatioColourFactors = {Numerator[#], Denominator[#]} & /@ Re[colourFactors];
    ImRatioColourFactors = {Numerator[#], Denominator[#]} & /@ Im[colourFactors];

    relevantSubexpressions = DeleteDuplicates[Cases[expr,
      Pattern[subexpr, Alternatives @@ subexpressions[[All,1]]] :> subexpr,
      Infinity, Heads -> True]];

    needsContext = !(FreeQ[expr, SARAH`Cp] && FreeQ[expr, SARAH`Mass]);

    cxxExpr = Parameters`ExpressionToString[
      Fold[ReplaceAll, expr, preCXXRules]];
    cxxExpr = StringReplace[cxxExpr, "\"" -> ""];

    genericFields = Sort[indices[[#,1]][GenericIndex[indices[[#,2]]]] & /@
      Table[k, {k,Length[indices]}]];
    sortedGenericInsertions = SortBy[#, First] & /@ genericInsertions;

    "template<class GenericFieldMap> struct " <> functionName <> "_impl\n" <>
    ": generic_sum_base\n{\n" <>
    functionName <> "_impl( const generic_sum_base &base )\n" <>
    ": generic_sum_base( base ) {} \n\n" <>
    "std::complex<double> operator()( void )\n{\n" <>
    "using boost::mpl::at;\n" <>
    "using boost::fusion::at_key;\n\n" <>

    StringJoin[
      "using " <> CXXNameOfGenericField[#] <>
      " = typename at<GenericFieldMap, " <>
        CXXKeyOfGenericField[#] <>
      ">::type;\n" &
      /@ genericFields] <> "\n" <>

    "typename field_index_map<GenericFieldMap>::type index_map;\n\n" <>

    If[Length[relevantSubexpressions] =!= 0,
       StringJoin[ToString[#] <> "<GenericFieldMap> " <>
         ToString[#] <> "_{ *this, index_map };\n" & /@
         relevantSubexpressions] <> "\n",
       ""] <>

    If[needsContext,
       "const context_with_vertices &context = *this;\n",
       ""] <>
    "std::complex<double> value = 0.0;\n\n" <>

    StringJoin[Riffle[
      "for( const auto &" <> CXXIndicesForField[#] <> " : " <>
        "index_range<" <> CXXNameOfGenericField[#] <> ">() ) {\n" <>
      "at_key<" <> CXXKeyOfGenericField[#] <> ">( index_map ) = " <>
        CXXIndicesForField[#] <> ";" & /@
      genericFields, "\n"]] <> "\n\n" <>
    "value += " <> cxxExpr <> ";\n" <>
    StringJoin[Table["}",{k,Length[indices]}]] <> "\n\n" <> 

    "return value;" <>
    "\n}\n};\n\n" <>

    "std::complex<double>" <> functionName <> "( void )\n{\n" <>
    "using GenericKeys = boost::mpl::vector<\n" <>
    StringJoin[Riffle[CXXKeyOfGenericField /@ genericFields, ",\n"]] <>
    "\n>;\n\n" <>

    "using GenericInsertions" <> " = boost::mpl::vector<\n" <>
    StringJoin[Riffle[
      "boost::mpl::vector<" <> StringJoin[Riffle[
          CXXDiagrams`CXXNameOfField[#, prefixNamespace -> "fields"] & /@ #, ", "]] <>
        ">" & /@ sortedGenericInsertions[[All,All,2]],
      ",\n"]] <> "\n>;\n\n" <>

    "using combinatorial_factors" <> " = boost::mpl::vector<\n" <>
    StringJoin[Riffle[
      "boost::mpl::int_<" <> ToString[#] <> ">" & /@ combinatorialFactors,
      ", "]] <> "\n>;\n" <>
    "using colour_factors" <> " = boost::mpl::vector<\n" <>
    StringJoin[Riffle[
      StringReplace["detail::complex_helper<detail::ratio_helper<"
        <> ToString[#1] <> ">, detail::ratio_helper<" <> ToString[#2] <> ">>" & @@@
        Transpose[{ReRatioColourFactors, ImRatioColourFactors}], {"{" -> "", "}" -> ""}],
      ", "]] <> "\n>;\n\n" <>

    "return accumulate_generic<GenericKeys, GenericInsertions,\n" <> 
      "combinatorial_factors, colour_factors, " <> functionName <> 
    "_impl>( *this );\n}"
  ]

(** \brief Return a list of the open field indices for a given
 * n-point correlation function.
 * \param the given n-point correlation function
 * \returns a list of the open field indices for a given
 * n-point correlation function.
 **)
ExternalIndicesForNPointFunction[nPointFunction_] :=
  Flatten[Cases[Join[nPointFunction[[1,1]], nPointFunction[[1,2]]],
            _[indices_List] :> indices]]

(** \brief Return the c++ expression for the container of the indices
 * of a given (possibly generic) field.
 * \param field the given field
 * \returns the c++ expression for the container of the indices
 * of a given (possibly generic) field.
 **)
CXXIndicesForField[SARAH`bar[field_]] := CXXIndicesForField[field]
CXXIndicesForField[Susyno`LieGroups`conj[field_]] := CXXIndicesForField[field]
CXXIndicesForField[head_[GenericIndex[index_Integer]]] := 
  "indices" <> StringTake[SymbolName[head],-1] <> ToString[index]
CXXIndicesForField[field_] :=
  If[Length[field] === 0, "std::array<int, 0>()",
     "std::array<int, " <> ToString[Length[field[[1]]]] <> ">{ " <>
       StringJoin[Riffle[ToString /@ field[[1]], ", "]] <> " }"]

(** \brief Determine whether a given field is a generic or a concrete
 * one.
 * \param field the given field
 * \returns `True` if the given field is generic and `False` otherwise.
 **)
IsGenericField[field_] :=
  Module[{head = Head[CXXDiagrams`RemoveLorentzConjugation[field]]},
    Switch[head,
           GenericS, True, 
           GenericF, True, 
           GenericV, True, 
           GenericU, True, 
           _, False]
  ] 

(** \brief Given a generic field, determine its key type used in the c++
 * code to uniquely label it.
 * \param genericField the given generic field
 * \returns its c++ key type.
 **)
CXXKeyOfGenericField[head_[GenericIndex[index_Integer]]] :=
  ToString[head] <> ToString[index] <> "Key"

(** \brief Given a (possibly conjugated) generic field,
 * return its c++ type.
 * \param genericField the given generic field
 * \returns its c++ type.
 **)
CXXNameOfGenericField[head_[GenericIndex[index_Integer]]] :=
  ToString[head] <> ToString[index]
CXXNameOfGenericField[SARAH`bar[field_]] :=
  "typename bar<" <> CXXNameOfGenericField[field] <> ">::type";
CXXNameOfGenericField[Susyno`LieGroups`conj[field_]] :=
  "typename conj<" <> CXXNameOfGenericField[field] <> ">::type";

(** \brief Return the c++ name for the helper class of the c++
 * version of a given n-point correlation function.
 * \param nPointFunction the given n-point correlation function
 * \returns the c++ name for the helper class of the c++
 * version of a given n-point correlation function.
 **)
CXXClassNameForNPointFunction[nPointFunction_] :=
  Module[{fields},
    fields = Vertices`StripFieldIndices[
      Join[nPointFunction[[1,1]], nPointFunction[[1,2]]]];
    "nPoint" <> StringJoin[ToString /@ Flatten[fields //. a_[b_] :> {a,b}]]
  ]

(** \brief Write a given n-point correlation function to the cache
 * \param nPointFunction the given n-point correlation function
 * \param nPointMeta the meta information about the given n-point
 * correlation function
 **)
CacheNPointFunction[nPointFunction_, nPointMeta_List] := 
  Module[{sarahOutputDir = SARAH`$sarahCurrentOutputMainDir,
          outputDir, nPointFunctionsDir, cacheName,
          nPointFunctionsFile,fileHandle,nPointFunctions,
          position},
    cacheName = CacheNameForMeta[nPointMeta];

    outputDir = FileNameJoin[{sarahOutputDir, ToString[FlexibleSUSY`FSEigenstates]}];
    nPointFunctionsDir = FileNameJoin[{outputDir, "NPointFunctions"}];
    nPointFunctionsFile = FileNameJoin[{nPointFunctionsDir, cacheName}];

    If[!FileExistsQ[nPointFunctionsFile],
       fileHandle = OpenWrite[nPointFunctionsFile];
       Write[fileHandle,{}];
       Close[fileHandle]];

    nPointFunctions = Get[nPointFunctionsFile];

    position = Position[nPointFunctions[[All,1]], nPointFunction[[1]]];
    If[Length[position] =!= 0,
       nPointFunctions[[position[[1,1]]]] = nPointFunction,

       AppendTo[nPointFunctions, nPointFunction]
    ];

    fileHandle = OpenWrite[nPointFunctionsFile];
    Write[fileHandle,nPointFunctions];
    Close[fileHandle];
  ]

(** \brief Retrieve an n-point correlation function from the cache
 * \param inFields the incoming fields of the n-point correlation
 * function
 * \param outFields the outgoing fields of the n-point correlation
 * function
 * \param nPointMeta the meta information of the n-point correlation
 * function
 * \returns the corresponding n-point correalation function from the
 * cache or `Null` if such a function could not be found.
 **)
CachedNPointFunction[inFields_List, outFields_List, nPointMeta_List] :=
  Module[{sarahOutputDir = SARAH`$sarahCurrentOutputMainDir,
          outputDir, nPointFunctionsDir, cacheName,
          nPointFunctionsFile, nPointFunctions,
          unindexedExternalFields, position},
    cacheName = CacheNameForMeta[nPointMeta];

    outputDir = FileNameJoin[{sarahOutputDir, ToString[FlexibleSUSY`FSEigenstates]}];
    nPointFunctionsDir = FileNameJoin[{outputDir, "NPointFunctions"}];
    nPointFunctionsFile = FileNameJoin[{nPointFunctionsDir, cacheName}];

    If[!FileExistsQ[nPointFunctionsFile],
       Return[Null]];

    nPointFunctions = Get[nPointFunctionsFile];

    unindexedExternalFields = {Vertices`StripFieldIndices[#[[1]]],
                               Vertices`StripFieldIndices[#[[2]]]} & /@
      nPointFunctions[[All,1]];

    position = Position[unindexedExternalFields,
      {inFields, outFields}, {1}, Heads -> False];
    If[Length[position] === 0,
       Null,
       nPointFunctions[[position[[1,1]]]]
    ]
  ]

(** \brief Return the name of the cache for given meta information
 * \param nPointMeta the given meta information
 * \returns the name of the cache file for given meta information.
 **)
CacheNameForMeta[nPointMeta_List] :=
  "cache_" <> StringJoin[Riffle[ToString /@ nPointMeta, "_"]] <> ".m"

(** \brief Translate SARAH-style fields to FeynArts-style fields
 * \param fields the list of SARAH-style fields
 * \param particleNamesFile the path to the SARAH-created FeynArts
 * particle names file.
 * \returns A list of the FeynArts names (as strings) for the given
 * SARAH-style fields.
 **)
FeynArtsNamesForFields[fields_List,particleNamesFile_String] :=
  Module[{lines, unindexedBaseFields, fieldLines,
          faFieldNames, faNameRules},
    lines = Utils`ReadLinesInFile[particleNamesFile];
    
    unindexedBaseFields = DeleteDuplicates[CXXDiagrams`AtomHead[
      CXXDiagrams`RemoveLorentzConjugation[#]] & /@ fields];

    fieldLines = Module[{fieldName = ToString[#]},
      Select[lines, StringMatchQ[#,___~~fieldName~~":"~~___] &][[1]]] & /@
        unindexedBaseFields;

    faFieldNames = ("FeynArts`" <> StringSplit[#][[2]]) & /@ fieldLines;
    
    faNameRules = Join[
      Sequence @@ {#[[1]][indices_List] :>
         StringDrop[#[[2]], -1] <> ", " <> ToString[indices] <> "]",
       #[[1]] -> #[[2]]} & /@ Transpose[{unindexedBaseFields, faFieldNames}],
      {SARAH`bar[field_String] :> "-" <> field,
       Susyno`LieGroups`conj[field_String] :> "-" <> field}
    ];
    
    fields //. faNameRules
  ]

(** \brief Determine the generic field type of a given field.
 * \param field the given field
 * \returns the generic type of the given generic field.
 **)
GenericFieldType[field_] :=
  Module[{head = CXXDiagrams`AtomHead[CXXDiagrams`RemoveLorentzConjugation[field]]},
    Switch[head,
           GenericS, GenericS,
           GenericF, GenericF,
           GenericV, GenericV,
           GenericU, GenericU,
           GenericT, GenericT,
           _, If[TreeMasses`IsScalar[head],GenericS,
                 If[TreeMasses`IsFermion[head],GenericF,
                    If[TreeMasses`IsVector[head],GenericV,
                      If[TreeMasses`IsGhost[head],GenericU,
                         "unrecognized field type " <> ToString[head]]]]]]

  ]

(** \brief Create the c++ code for the necessary headers for evaluation
 * of n-point correlation functions.
 * \param LoopFunctions the loop function library to be used
 * \returns the c++ code for the necessary headers for evaluation
 * of n-point correlation functions.
 **)
CreateCXXHeaders[OptionsPattern[{LoopFunctions -> "FlexibleSUSY"}]] :=
  "#include \"cxx_qft/" <> FlexibleSUSY`FSModelName <> "_npointfunctions.hpp\"\n" <>
  "#include \"concatenate.hpp\"\n\n" <>
  "#include <boost/fusion/include/at_key.hpp>\n\n" <>
  Switch[OptionValue[LoopFunctions],
         "LoopTools", "#include <clooptools.h>",
         "FlexibleSUSY", "#include \"numerics.h\""]
     

End[];
EndPackage[];
