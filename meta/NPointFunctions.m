(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

(*@assumptions:
1) there are no quartic gluon vertices inside diagrams => one can calculate
colour factor for diagram separately from Lorentz factor
2) 4-point vertices are not supported *)
BeginPackage@"NPointFunctions`";

If[!ValueQ[Model`Name],
   Print["Error: Model`Name is not defined. Did you call SARAH`Start[\"Model\"]?"];
   Quit[1];
];

LoopLevel::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes the loop level at which to calculate amplitudes.

def. 1 | 0";
Regularize::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes the regularization scheme to be used.

DimensionalReduction | DimensionalRegularization";
UseCache::usage=
"Option for NPointFunctions`NPointFunction[].
Cache and reuse the expressions generated by FeynArts/FormCalc.
@note @todo there is no difference between different KeepProcesses and
OnShellFlag values

def. True | False";
ZeroExternalMomenta::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes whether to set the external momenta to zero or leave them undetermined.

def. True | False | OperatorsOnly";
OnShellFlag::usage=
"Option for NPointFunctions`NPointFunction[].
Use on-shell external fields or not.

def. True | False";

KeepProcesses::usage=
"Option for NPointFunctions`NPointFunction[].
Keep specific processes in FeynArts.

def. {} | Any sublist of @todo";
Irreducible::usage=
"Possible value for KeepProcesses.
Exclude irreducible topologies.";
Triangles::usage=
"Possible value for KeepProcesses.
Exclude all topologies except triangle ones.";
FourFermionScalarPenguins::usage=
"Possible value for KeepProcesses.
Exclude all processes except 4-fermion penguins with scalar propagating from
one fermionic chain to another one.
Keep
1) triangle-like topologies;
2) \"self-energy\" diagrams on external fermionic lines
amplitudes.";
FourFermionMassiveVectorPenguins::usage=
"Possible value for KeepProcesses.
Exclude all processes except 4-fermion penguins with massive vector propagating
from one fermionic chain to another one.
Keep
1) triangle-like topologies;
2) \"self-energy\" diagrams on external fermionic lines
amplitudes.";
FourFermionFlavourChangingBoxes::usage=
"Possible value for KeepProcesses.
Exclude all processes except 4-fermion boxes with massive vector bosons.";

DimensionalReduction::usage=
"Possible value for the Regularize option

(Technically, a wrapper for FlexibleSUSY`.`DRbar)";
DimensionalRegularization::usage=
"Possible value for the Regularize option

(Technically, a wrapper for FlexibleSUSY`.`MSbar)";

GenericS::usage=
"A symbol that acts as a placeholder for any scalar field.";
GenericF::usage=
"A symbol that acts as a placeholder for any fermion field.";
GenericV::usage=
"A symbol that acts as a placeholder for any vector field.";
GenericU::usage=
"A symbol that acts as a placeholder for any ghost field.";

GenericSum::usage=
"Represent a sum over a set of generic fields.";
GenericIndex::usage=
"Represent an index of a generic field.";
LorentzIndex::usage=
"Represent a Lorentz index of a generic field.";

(*functions*)
{NPointFunction,VerticesForNPointFunction,CreateCXXHeaders,CreateCXXFunctions,
CreateCXXFToFConversionInNucleus};

SetAttributes[
   {
   LoopLevel,Regularize,UseCache,ZeroExternalMomenta,OnShellFlag,OperatorsOnly,
   KeepProcesses,
   DimensionalReduction,DimensionalRegularization,
   Irreducible,Triangles,
   GenericS,GenericF,GenericV,GenericU,
   GenericSum,GenericIndex,LorentzIndex
   },
   {Locked,Protected}];

NPointFunctions`internal`contextPath = $ContextPath;
$ContextPath = {"NPointFunctions`","System`"};
Begin["`internal`"];
(* ============================== Type definitions ========================== *)
Module[
   {
      allParticles = TreeMasses`GetParticles[],
      dimensionfullConverter = If[TreeMasses`GetDimension@#>1,#[{_Symbol}],#] &,
      conjConverter = Through[Sequence[Susyno`LieGroups`conj,#&][#]] &,
      barConverter = Through[Sequence[SARAH`bar,#&][#]] &,
      scalarList,fermionList,vectorList
   },
   scalarList = Join[
      dimensionfullConverter /@ Cases[allParticles, _?TreeMasses`IsRealScalar],
      conjConverter /@ dimensionfullConverter /@ Cases[allParticles, _?TreeMasses`IsComplexScalar]
   ];
   fermionList = Join[
      dimensionfullConverter /@ Cases[allParticles, _?TreeMasses`IsMajoranaFermion],
      barConverter /@ dimensionfullConverter /@ Cases[allParticles, _?TreeMasses`IsDiracFermion]
   ];
   vectorList = Join[
      dimensionfullConverter /@ Cases[allParticles, _?TreeMasses`IsRealVector],
      conjConverter /@ dimensionfullConverter /@ Cases[allParticles, _?TreeMasses`IsComplexVector]
   ];
   `type`scalarField = Alternatives @@ scalarList;
   `type`fermionField = Alternatives @@ fermionList;
   `type`vectorField = Alternatives @@ vectorList;
   `type`physicalField = Alternatives @@ Join[scalarList,fermionList,vectorList];
   {`type`scalarField,`type`fermionField,`type`vectorField,`type`physicalField} ~ SetAttributes ~ {Locked,Protected};
];

`type`wilsonBasis = {Rule[_String,_]..};
`type`colourProjector = Identity|SARAH`Delta;

`type`genericField =
   (GenericS | GenericF | GenericV | GenericU)[GenericIndex[_Integer]] |
   SARAH`bar[(GenericF | GenericU)[GenericIndex[_Integer]]] |
   Susyno`LieGroups`conj[(GenericS | GenericV)[GenericIndex[_Integer]]];
`type`process = {{__},{__}};
`type`subexpressions = {Rule[_Symbol,_]...};
`type`summation = {{`type`genericField,_}..};
`type`genericSum = GenericSum[{__},`type`summation];
`type`classFields = {{__}..};
`type`classCombinatoricalFactors = {__Integer};
`type`classColorFactors = {__};
`type`npf =
   {
   `type`process,
   {
      {
         {`type`genericSum..},
         {`type`classFields..},
         {`type`classCombinatoricalFactors..},
         {`type`classColorFactors..}
      },
      `type`subexpressions
   }
};

`type`cxxToken = _String?(StringMatchQ[#,RegularExpression@"@[^@\n]+@"]&);
`type`cxxReplacementRules = {Rule[`type`cxxToken,_String]..};

`subkernel`message::errNoTopologies =
"No topologies are generated for a given set of options.";
`subkernel`message::errNoDiagrams =
"No diagrams are generated for a given set of options.";

`subkernel`error[message_] := Utils`AssertOrQuit[False,message];
`subkernel`error // Utils`MakeUnknownInputDefinition;
`subkernel`error ~ SetAttributes ~ {Locked,Protected,HoldFirst};

`cxx`getLength[obj:`type`wilsonBasis] := ToString@Length@obj;
`cxx`getLength // Utils`MakeUnknownInputDefinition;
`cxx`getLength ~ SetAttributes ~ {Locked,Protected};

getDirectories[] :=
Module[{},
   {
      {
         #1,
         #3,
         FlexibleSUSY`$flexiblesusyMetaDir
      },
      {
         FileNameJoin@{#2,SARAH`ModelName<>ToString@FlexibleSUSY`FSEigenstates},
         FileNameJoin@{#2,"ParticleNamesFeynArts.dat"},
         FileNameJoin@{#2,"ParticleNamespaces.m"},
         FileNameJoin@{#2,StringJoin["Substitutions-",SARAH`ModelName,ToString@FlexibleSUSY`FSEigenstates,".m"]}
      }
   }&@@({FileNameJoin@{#,"NPointFunctions"},FileNameJoin@{#,"FeynArts"},FileNameJoin@{#,"FormCalc"}}&[FileNameJoin@{SARAH`$sarahCurrentOutputMainDir,ToString@FlexibleSUSY`FSEigenstates}])
];
getDirectories // Utils`MakeUnknownInputDefinition;
getDirectories ~ SetAttributes ~ {Locked,Protected};

getIndent[obj:_String] :=
First@StringCases[obj,StartOfString~~"\n"...~~indent:" "...:>indent];
getIndent[obj:{__String}] :=
First/@StringCases[obj,StartOfString~~"\n"...~~indent:" "...:>indent];
getIndent // Utils`MakeUnknownInputDefinition;
getIndent ~ SetAttributes ~ {Locked,Protected};

getConjugated[obj:`type`genericField] := Switch[Head@obj,
   SARAH`bar | Susyno`LieGroups`conj, obj[[1]],
   GenericS | GenericV, Susyno`LieGroups`conj@obj,
   GenericF | GenericU, SARAH`bar@obj
];
getConjugated[obj:`type`scalarField|`type`vectorField] :=
   Susyno`LieGroups`conj@obj;
getConjugated[obj:`type`fermionField] :=
   SARAH`bar@obj;
getConjugated // Utils`MakeUnknownInputDefinition;
getConjugated ~ SetAttributes ~ {Locked,Protected};

getIndex[obj:`type`genericField] :=
(obj /. {SARAH`bar->Identity,Susyno`LieGroups`conj->Identity})[[1,1]];
getIndex // Utils`MakeUnknownInputDefinition;
getIndex ~ SetAttributes ~ {Locked,Protected};

removeIndent[obj:_String] := StringReplace[obj,StartOfLine~~getIndent[obj]->""];
removeIndent // Utils`MakeUnknownInputDefinition;
removeIndent ~ SetAttributes ~ {Locked,Protected};

replaceTokens[code:_String, rules:`type`cxxReplacementRules] :=
StringJoin[
   StringReplace[#,"\n"->StringJoin["\n",getIndent@#]] &/@ StringReplace[StringSplit[removeIndent@code,"\n"],rules]~Riffle~"\n"];
replaceTokens // Utils`MakeUnknownInputDefinition;
replaceTokens ~ SetAttributes ~ {Locked,Protected};

getProcess[obj:`type`npf] := obj[[1]];
getProcess // Utils`MakeUnknownInputDefinition;
getProcess ~ SetAttributes ~ {Locked,Protected};

getExternalMomenta[obj:`type`npf] :=
DeleteDuplicates@Cases[{getGenericSums@obj,getSubexpressions@obj},HoldPattern@SARAH`Mom[_Integer,___],Infinity];
getExternalMomenta // Utils`MakeUnknownInputDefinition;
getExternalMomenta ~ SetAttributes ~ {Locked,Protected};

getExternalIndices[obj:`type`npf] :=
DeleteDuplicates@Flatten@Level[getProcess@obj,{4,5}];
getExternalIndices // Utils`MakeUnknownInputDefinition;
getExternalIndices ~ SetAttributes ~ {Locked,Protected};

getGenericSums::errSimpleOnly =
"Only the case without subexpressions is supported.";
getGenericSums::errBadIndex =
"Specified index(es) `1` is (are) outside the allowed region `2`.";
getGenericSums[obj:`type`npf] := obj[[2,1,1]];
getGenericSums[obj:`type`npf, int:{__Integer}] :=
Module[{unique = DeleteDuplicates@int},
   {
      getProcess@obj,
      {
         {
            getGenericSums[obj][[unique]],
            getClassFields[obj][[unique]],
            getClassCombinatoricalFactors[obj][[unique]],
            getClassColorFactors[obj][[unique]]
         },
         getSubexpressions@obj
      }
   }
] /; And[
   Utils`AssertOrQuit[getSubexpressions@obj == {},getGenericSums::errSimpleOnly],
   Utils`AssertOrQuit[containsQ[#,int],getGenericSums::errBadIndex,int,#]&[getIndexRange[getClassCombinatoricalFactors@obj]]
];
getGenericSums // Utils`MakeUnknownInputDefinition;
getGenericSums ~ SetAttributes ~ {Locked,Protected};

getIndexRange[obj:{___}] := {1, Length@obj};
getIndexRange // Utils`MakeUnknownInputDefinition;
getIndexRange ~ SetAttributes ~ {Locked,Protected};

containsQ[obj:{_Integer,_Integer}, int:_Integer] := IntervalMemberQ[Interval@obj,int];
containsQ[obj:{_Integer,_Integer}, int:{__Integer}] := And@@(containsQ[obj,#]&/@int);
containsQ // Utils`MakeUnknownInputDefinition;
containsQ ~ SetAttributes ~ {Locked,Protected};

getClassFields[obj:`type`npf] := obj[[2,1,2]];
getClassFields // Utils`MakeUnknownInputDefinition;
getClassFields ~ SetAttributes ~ {Locked,Protected};

getClassCombinatoricalFactors[obj:`type`npf] := obj[[2,1,3]];
getClassCombinatoricalFactors // Utils`MakeUnknownInputDefinition;
getClassCombinatoricalFactors ~ SetAttributes ~ {Locked,Protected};

getClassColorFactors[obj:`type`npf] := obj[[2,1,4]];
getClassColorFactors // Utils`MakeUnknownInputDefinition;
getClassColorFactors ~ SetAttributes ~ {Locked,Protected};

getSubexpressions[obj:`type`npf] := obj[[2,2]];
getSubexpressions // Utils`MakeUnknownInputDefinition;
getSubexpressions ~ SetAttributes ~ {Locked,Protected};

getName[obj:`type`physicalField] :=
Module[{nakedField=obj /. {SARAH`bar->Identity,Susyno`LieGroups`conj->Identity}},
   Switch[nakedField,
   _Symbol,nakedField,
   (_Symbol)[{_Symbol}],Head@nakedField]
];
getName[obj:`type`genericField] :=
Head[obj /. {SARAH`bar->Identity,Susyno`LieGroups`conj->Identity}];
getName // Utils`MakeUnknownInputDefinition;
getName ~ SetAttributes ~ {Locked,Protected};

cxxName[obj:`type`genericField] :=
Switch[Head@obj,
   SARAH`bar,"typename bar<"<>ToString[obj[[1,0]]]<>ToString[obj[[1,1,1]]]<>">::type",
   Susyno`LieGroups`conj,"typename conj<"<>ToString[obj[[1,0]]]<>ToString[obj[[1,1,1]]]<>">::type",
   _,ToString[obj[[0]]]<>ToString[obj[[1,1]]]
];
cxxName // Utils`MakeUnknownInputDefinition;
cxxName ~ SetAttributes ~ {Locked,Protected};

`cxx`getIndex[obj:`type`physicalField] :=
Module[{nakedField=obj /. {SARAH`bar->Identity,Susyno`LieGroups`conj->Identity}},
   Switch[nakedField,
   _Symbol,"",
   (_Symbol)[{_Symbol}],StringDrop[ToString[nakedField[[1, 1]]],2]]
];
`cxx`getIndex // Utils`MakeUnknownInputDefinition;
`cxx`getIndex ~ SetAttributes ~ {Locked,Protected};

cxxIndex[obj:`type`genericField] :=
"indices"<>StringTake[SymbolName[obj[[0]]],-1]<>ToString[obj[[1,1]]] &@ CXXDiagrams`RemoveLorentzConjugation[obj];
cxxIndex // Utils`MakeUnknownInputDefinition;
cxxIndex ~ SetAttributes ~ {Locked,Protected};

getGenericFields[obj:`type`genericSum] := First/@Last[obj];
getGenericFields[obj:`type`summation] := First/@obj;
getGenericFields[objs:{`type`genericSum..}] := (First/@Last@#)&/@objs;
getGenericFields // Utils`MakeUnknownInputDefinition;
getGenericFields ~ SetAttributes ~ {Locked,Protected};

getExpression[obj:`type`genericSum] := First@obj;
getExpression // Utils`MakeUnknownInputDefinition;
getExpression ~ SetAttributes ~ {Locked,Protected};

getSummationData[obj:`type`genericSum] := Last@obj;
getSummationData // Utils`MakeUnknownInputDefinition;
getSummationData ~ SetAttributes ~ {Locked,Protected};

getClassFieldRules[obj:`type`npf] :=
MapThread[Function[fields,MapThread[Rule,{#1,fields}]]/@#2&,{getGenericFields@getGenericSums@obj,getClassFields@obj}];
getClassFieldRules // Utils`MakeUnknownInputDefinition;
getClassFieldRules ~ SetAttributes ~ {Locked,Protected};

setSubexpressions[obj:`type`npf, newsubs:`type`subexpressions] := ReplacePart[obj,{2,2}->newsubs];
setSubexpressions // Utils`MakeUnknownInputDefinition;
setSubexpressions ~ SetAttributes ~ {Locked,Protected};

applySubexpressions[obj:`type`npf] :=
Module[{result},
   WriteString["stdout"~OutputStream~1,"Applying subexpressions ... "];
   result = ReplacePart[obj,{2,1,1}->ReplaceRepeated[getGenericSums@obj,getSubexpressions@obj]]~setSubexpressions~{};
   WriteString["stdout"~OutputStream~1,"done\n"];
   result
];
applySubexpressions // Utils`MakeUnknownInputDefinition;
applySubexpressions ~ SetAttributes ~ {Locked,Protected};

CreateCXXFToFConversionInNucleus::usage=
"@todo";
CreateCXXFToFConversionInNucleus::errFermion=
"Input should be
<fermion> -> <fermion> or { { <fermion> -> <fermion> }.. }
and not
`1`";
CreateCXXFToFConversionInNucleus[{{}}] := {{},"",""};
CreateCXXFToFConversionInNucleus[arg:{{_->_}..}] :=
Module[
   {
      data = CreateCXXFToFConversionInNucleus@@#&/@arg,
      vertices,header,code
   },
   vertices = DeleteDuplicates[Join@@(data[[All,1]])];
   header = data[[1,2]];
   code = StringRiffle[data[[All,3]],"\n\n"];
   {vertices,header,code}
];
CreateCXXFToFConversionInNucleus[inF_->outF_] :=
Module[
   {
      nameForUpQuarkClass = "zpinguins_u"<>ToString@inF<>ToString@outF<>"_1loop",
      nameForUpDownClass  = "zpinguins_d"<>ToString@inF<>ToString@outF<>"_1loop",
      header,
      fiG, foG, uiG, uoG, (* particle | incoming/outgoing | with generation *)
      regulator,
      inner = SARAH`sum[i_,1,4,SARAH`g[i_,i_]*SARAH`Mom[#1,i_]*SARAH`Mom[#2,i_]]&,
      uQ=SARAH`UpQuark,uNPF,
      dQ=SARAH`DownQuark, dNPF,
      dimension6Template,
      l=SARAH`Lorentz, p=SARAH`Mom, m=SARAH`Mass,
      sp,
      codeU,codeD,
      dressedU,dressedD,assumptionReplacements
   },
   header=CreateCXXHeaders[];
   sp[particle_,num_] := SARAH`DiracSpinor[#,p@num,m@#] &@ particle@{Symbol["SARAH`gt"<>ToString@num]};

   Print["Analytical calculation for ",inF,"->",outF," started ..."];
   uNPF = NPointFunction[{inF,uQ},{outF,uQ},
      OnShellFlag -> True,
      UseCache -> False,
      ZeroExternalMomenta -> OperatorsOnly,
      KeepProcesses ->
   {FourFermionMassiveVectorPenguins,FourFermionScalarPenguins,FourFermionFlavourChangingBoxes}];
   dNPF = NPointFunction[{inF,dQ},{outF,dQ},
      OnShellFlag -> True,
      UseCache -> False,
      ZeroExternalMomenta -> OperatorsOnly,
      KeepProcesses ->
   {FourFermionMassiveVectorPenguins,FourFermionScalarPenguins,FourFermionFlavourChangingBoxes}];

   { fiG, uiG, foG, uoG } = Flatten@getProcess@uNPF;
   { fiG, diG, foG, doG } = Flatten@getProcess@dNPF;
   regulator = m@fiG^2;
   assumptionReplacements =
      {
         inner[fiG,foG] :> m@fiG^2,
         inner[uiG,fiG] :> m@fiG*Sqrt[m@uiG^2+regulator],
         inner[uoG,fiG] :> inner[uiG,fiG],
         inner[uoG,foG] :> m@fiG^2/2+inner[uiG,fiG],
         inner[diG,fiG] :> m@fiG*Sqrt[m@diG^2+regulator],
         inner[doG,fiG] :> inner[diG,fiG],
         inner[doG,foG] :> m@fiG^2/2+inner[diG,fiG]
      };
   {uNPF,dNPF} = {uNPF,dNPF} //. assumptionReplacements;

   Print["Analytical calculation for ",inF,"->",outF," done."];
   dimension6Template[i_,o_,q_] :=
      {
         (*@note 6 means PR, 7 means PL.*)
         ("S_LL_via_"<>ToString@q) -> dc[o~sp~3,7,i~sp~1] dc[q~sp~4,7,q~sp~2],
         ("S_LR_via_"<>ToString@q) -> dc[o~sp~3,7,i~sp~1] dc[q~sp~4,6,q~sp~2],
         ("S_RL_via_"<>ToString@q) -> dc[o~sp~3,6,i~sp~1] dc[q~sp~4,7,q~sp~2],
         ("S_RR_via_"<>ToString@q) -> dc[o~sp~3,6,i~sp~1] dc[q~sp~4,6,q~sp~2],
         (*@note Q: why names of coeffients are not correct? A: they are
          *correct, one just need to commute projectors with Dirac matrices,
          *what changes 6 to 7 or 7 to 6.*)
         ("V_LL_via_"<>ToString@q) -> dc[o~sp~3,6,l@1,i~sp~1] dc[q~sp~4,6,l@1,q~sp~2],
         ("V_LR_via_"<>ToString@q) -> dc[o~sp~3,6,l@1,i~sp~1] dc[q~sp~4,7,l@1,q~sp~2],
         ("V_RL_via_"<>ToString@q) -> dc[o~sp~3,7,l@1,i~sp~1] dc[q~sp~4,6,l@1,q~sp~2],
         ("V_RR_via_"<>ToString@q) -> dc[o~sp~3,7,l@1,i~sp~1] dc[q~sp~4,7,l@1,q~sp~2],
         (*@note Q: why minus? A: because FormCalc`s -6,Lor[1],Lor[2] is ours
          *-I*sigma[1,2] (according to FC definition of antisymmetrization), when
          *taking this twice we get I*I=-1. @todo one really need to check "I conventions"
          *for FC because it cites [Ni05] for Fierz identities, where our
          *conventions are used, but in FC manual on the page 20 weird convention for sigma_munu is shown.*)
         ("minus_T_LL_via_"<>ToString@q) -> dc[o~sp~3,-7,l@1,l@2,i~sp~1] dc[q~sp~4,-7,l@1,l@2,q~sp~2],
         ("minus_T_RR_via_"<>ToString@q) -> dc[o~sp~3,-6,l@1,l@2,i~sp~1] dc[q~sp~4,-6,l@1,l@2,q~sp~2]
      };
   uNPF = uNPF~WilsonCoeffs`InterfaceToMatching~dimension6Template[inF,outF,uQ];
   dNPF = dNPF~WilsonCoeffs`InterfaceToMatching~dimension6Template[inF,outF,dQ];

   Print["C++ code calculation for ",inF,"->",outF," started ..."];
   codeU = CreateCXXFunctions[uNPF,
      nameForUpQuarkClass,
      SARAH`Delta,
      dimension6Template[inF,outF,uQ] ][[2]];
   codeD = CreateCXXFunctions[dNPF,
      nameForUpDownClass,
      SARAH`Delta,
      dimension6Template[inF,outF,dQ] ][[2]];
   Print["C++ code calculation for ",inF,"->",outF," done."];
   {
      DeleteDuplicates@Join[VerticesForNPointFunction@uNPF,VerticesForNPointFunction@dNPF],
      header,
      codeU<>"\n\n"<>codeD
   }
] /; Utils`AssertOrQuit[
   TrueQ@@And/@TreeMasses`IsFermion@{inF,outF},
   CreateCXXFToFConversionInNucleus::errFermion,
   inF->outF];
CreateCXXFToFConversionInNucleus // Utils`MakeUnknownInputDefinition;
CreateCXXFToFConversionInNucleus ~ SetAttributes ~ {Locked,Protected};

Options[NPointFunction]={
   LoopLevel -> 1,
   Regularize -> Switch[FlexibleSUSY`FSRenormalizationScheme,
      FlexibleSUSY`DRbar, DimensionalReduction,
      FlexibleSUSY`MSbar, DimensionalRegularization],
   UseCache -> True,
   ZeroExternalMomenta -> True,
   OnShellFlag -> True,
   KeepProcesses -> {}
};
NPointFunction::usage=
"@brief Calculate the n-point correlation function for a List of incoming and
a List of outgoing fields.
@param inFields a List of incoming fields
@param outFields a List of outgoing fields
@param LoopLevel the loop level at which to perform the calculation
@param Regularize the regularization scheme to apply
@param UseCache whether to attempt to read and write the result from and to
the cache.
@param ZeroExternalMomenta whether to set the external momenta to zero or leave
them undetermined.
@param KeepProcesses a list or single symbol of topologies to keep when
calculation the n-point correlation function
@returns the corresponding n-point correlation function
@note only a loop level of 1 is currently supported
@note the recognized regularization schemes are:
 - DimensionalReduction
 - DimensionalRegularization
@note when not setting the external momenta to zero one should use LoopTools
for the evaluation of the loop functions.";
NPointFunction::errinFields=
"The element '`1`' of inFields is an incorrect one.

inFields should contain only names from the list of `2` particles
`3`.
(SARAH`.`bar for fermions and Susyno`.`LieGroups`.`conj for scalars is
acceptable as well)
@note now only restricted set is supported";
NPointFunction::erroutFields=
"The element '`1`' of outFields is an incorrect one.

outFields should contain only names from the list of `2` particles
`3`.
@note now only restricted set is supported";
NPointFunction::errLoopLevel=
"Incorrect number of loops.

Only loop level 1 is supported";
NPointFunction::errRegularize=
"Unknown regularization scheme `1`.

Currently DimensionalReduction, DimensionalRegularization are supported.";
NPointFunction::errUseCache=
"UseCache must be either True or False.";
NPointFunction::errZeroExternalMomenta=
"ZeroExternalMomenta must be True, False or OperatorsOnly.";
NPointFunction::errOnShellFlag=
"OnShellFlag must be either True or False.";
NPointFunction::errKeepProcesses=
"KeepProcesses must be sublist of
{
   `1`
}.";
NPointFunction::errInputFields=                                                 (* @utodo modify it for usage of bosons also *)
"Only external scalars/fermions are supported (@todo FOR NOW).";
NPointFunction::errUnknownOptions=
"Unknown option(s):
`1`.

Currently supported options are:
`2`.";
NPointFunction[inFields_,outFields_,opts:OptionsPattern[]] :=
Module[
   {
      loopLevel = OptionValue[LoopLevel],
      regularizationScheme = OptionValue[Regularize],
      zeroExternalMomenta = OptionValue[ZeroExternalMomenta],
      excludeProcesses = OptionValue[KeepProcesses],                     (*@todo is not checked yet!*)
      onShellFlag = OptionValue[OnShellFlag],
      nPointFunctionsDir,feynArtsModel,particleNamesFile,
      particleNamespaceFile,substitutionsFile,formCalcDir,fsMetaDir,
      subKernel,
      currentPath, currentDirectory,
      inFANames,outFANames,
      nPointFunction
   },
   {
      {nPointFunctionsDir,formCalcDir,fsMetaDir},
      {feynArtsModel,particleNamesFile,particleNamespaceFile,substitutionsFile}
   } = getDirectories[];

   If[!DirectoryQ@nPointFunctionsDir,CreateDirectory@nPointFunctionsDir];
   If[OptionValue@UseCache,
      nPointFunction = CachedNPointFunction[
         inFields,outFields,nPointFunctionsDir,
         OptionValue[NPointFunction,Options[NPointFunction][[All, 1]]]];
      If[nPointFunction =!= Null, Return@nPointFunction]
   ];

   If[!FileExistsQ[feynArtsModel <> ".mod"],
      subKernel = LaunchSubkernelFor@"creation of FeynArts model file";
      GenerateFAModelFileOnKernel@subKernel;                                    (*generates .dat .mod .m files insiide FeynArts directory*)
      WriteParticleNamespaceFile@particleNamespaceFile;
      CloseKernels@subKernel;
   ];

   subKernel = LaunchSubkernelFor@"FormCalc code generation";

   inFANames = FANamesForFields[inFields, particleNamesFile];
   outFANames = FANamesForFields[outFields, particleNamesFile];

   currentPath = $Path;
   currentDirectory = Directory[];

   DistributeDefinitions[currentPath, currentDirectory,
      fsMetaDir, formCalcDir, feynArtsModel,
      particleNamesFile, substitutionsFile, particleNamespaceFile,
      inFANames, outFANames, loopLevel, regularizationScheme,
      zeroExternalMomenta, excludeProcesses, onShellFlag];

   SetSharedFunction[subWrite,Print];
   nPointFunction = RemoveEmptyGenSums@ParallelEvaluate[
      $Path = currentPath;
      SetDirectory@currentDirectory;
      Get@FileNameJoin@{fsMetaDir, "NPointFunctions", "internal.m"};

      NPointFunctions`SetInitialValues[formCalcDir, feynArtsModel,
         particleNamesFile, substitutionsFile, particleNamespaceFile];

      NPointFunctions`NPointFunctionFAFC[
         ToExpression@inFANames, ToExpression@outFANames,
         LoopLevel -> loopLevel,
         Regularize -> regularizationScheme,
         ZeroExternalMomenta -> zeroExternalMomenta,
         KeepProcesses -> excludeProcesses,
         OnShellFlag -> onShellFlag],
      subKernel
   ];
   CloseKernels@subKernel;
   UnsetShared[subWrite,Print];

   If[OptionValue@UseCache,CacheNPointFunction[
      nPointFunction,nPointFunctionsDir,
   OptionValue[NPointFunction,Options[NPointFunction][[All,1]]]]];

   nPointFunction
] /; internalNPointFunctionInputCheck[inFields,outFields,opts];
NPointFunction // Utils`MakeUnknownInputDefinition;
NPointFunction ~ SetAttributes ~ {Locked,Protected};

subWrite::usage =
"@brief Prints a string.
@note SetSharedFunction is not working with Locked or ReadProtected attributes.
@note SetSharedFunction does not cause names leaking.";
subWrite[str_String] := WriteString["stdout"~OutputStream~1,str];
subWrite ~ SetAttributes ~ {Protected};

internalNPointFunctionInputCheck[inFields:{__},outFields:{__},opts___] :=
Module[
   {
      aoq = Utils`AssertOrQuit,
      ip = TreeMasses`IsParticle,
      allowedParticles = Cases[TreeMasses`GetParticles[],_?TreeMasses`IsScalar|_?TreeMasses`IsFermion],(*@todo add |_?TreeMasses`IsVector*)
      definedOptions = Part[Options@NPointFunction,All,1],
      unknownOptions = FilterRules[{opts},Except@Part[Options@NPointFunction,All,1]],
      allProcesses={Irreducible,FourFermionFlavourChangingBoxes,Triangles,FourFermionScalarPenguins,FourFermionMassiveVectorPenguins,FourFermionFlavourChangingBoxes}
   },
   aoq[ip@#,NPointFunction::errinFields,#,GetSARAHModelName[],allowedParticles]&/@inFields;
   aoq[ip@#,NPointFunction::erroutFields,#,GetSARAHModelName[],allowedParticles]&/@outFields;
   aoq[TreeMasses`IsScalar@#||TreeMasses`IsFermion@#,NPointFunction::errInputFields]&/@Join[inFields,outFields];(*@todo add vector bosons.*)
   aoq[unknownOptions === {},NPointFunction::errUnknownOptions,unknownOptions,definedOptions];
   (*Now we know that all options are iside allowed list.*)
   Cases[{opts},Rule[LoopLevel,x_]:>
      aoq[x===1,NPointFunction::errLoopLevel]];
   Cases[{opts},Rule[Regularize,x_]:>
      aoq[MemberQ[{DimensionalReduction,DimensionalRegularization},x],NPointFunction::errRegularize,x]];
   Cases[{opts},Rule[UseCache,x_]:>
      aoq[x===True || x===False,NPointFunction::errUseCache]];
   Cases[{opts},Rule[ZeroExternalMomenta,x_]:>
      aoq[MemberQ[{True,False,OperatorsOnly},x],NPointFunction::errZeroExternalMomenta]];
   Cases[{opts},Rule[OnShellFlag,x_]:>
      aoq[x===True || x===False,NPointFunction::errOnShellFlag]];
   Cases[{opts},Rule[KeepProcesses,x_]:>
      aoq[And@@Map[MemberQ[allProcesses~Append~Null,#]&,If[Head@x===List,x,{x}]],NPointFunction::errKeepProcesses,StringJoin@Riffle[ToString/@allProcesses,",\n   "]]];
   True
];
internalNPointFunctionInputCheck // Utils`MakeUnknownInputDefinition;
internalNPointFunctionInputCheck ~ SetAttributes ~ {Locked,Protected};

VerticesForNPointFunction::usage=
"@brief Return a list of all vertices needed to calculate a given
n-point correlation function.
@param nPointFunction the given n-point correlation function
@returns a list of all vertices needed to calculate a given
n-point correlation function.temp";
VerticesForNPointFunction[obj:`type`npf] :=
Module[
   {
      genSums = getGenericSums@obj,
      substitutions = getSubexpressions@obj,
      classRules = getClassFieldRules@obj,
      positionsSubsWithVert =
         DeleteDuplicates[#[[1]] &/@ Position[getSubexpressions@obj, SARAH`Cp[__]]],
      rulesWithVertices,vertsGen,GetVertex
   },
   rulesWithVertices = substitutions[[positionsSubsWithVert]];
   GetVertex[vertGen_,rules_] := vertGen/.#&/@rules;
   vertsGen = DeleteDuplicates@Cases[#, SARAH`Cp[fields__] :> {fields},
      Infinity,Heads -> True] &/@ (genSums/.rulesWithVertices);
   DeleteDuplicates[Vertices`StripFieldIndices/@#&/@Flatten[MapThread[GetVertex,{vertsGen,classRules}],2]]
];
VerticesForNPointFunction // Utils`MakeUnknownInputDefinition;
VerticesForNPointFunction ~ SetAttributes ~ {Locked,Protected};

GetSARAHModelName::usage=
"@brief Return the SARAH model name as to be passed to SARAH`.`Start[].
@returns the SARAH model name as to be passed to SARAH`.`Start[].";
GetSARAHModelName[] :=
If[SARAH`submodeldir =!= False,
      SARAH`modelDir <> "-" <> SARAH`submodeldir,
      SARAH`modelDir
];
GetSARAHModelName // Utils`MakeUnknownInputDefinition;
GetSARAHModelName ~ SetAttributes ~ {Locked,Protected};

LaunchSubkernelFor::usage=
"@brief Tries to launch a subkernel without errors.
If it fails, tries to explain the reason using message for specifying its
activity.
@param message String, which contains description of activity for which this
subkernel is launched for.
@returns subkernel name.
@note Mathematica 7 returns KernelObject[__], 11.3 returns {KernelObject[__]}
@note for Mathematica 7 some functions have the same names as in SARAH`.`";
LaunchSubkernelFor::errKernelLaunch=
"Unable to launch subkernel(s) during calculations for
`1`
because of error:";
LaunchSubkernelFor[message_String] /; $VersionNumber===7.0 :=
Module[{kernelName},
   Off[Parallel`Preferences`add::shdw,
      Parallel`Preferences`set::shdw,
      Parallel`Preferences`list::shdw,
      Parallel`Preferences`tr::shdw,
      Parallel`Protected`processes::shdw,
      SubKernels`Description::shdw];
   kernelName = Utils`EvaluateOrQuit[
      LaunchKernels[1],
      LaunchSubkernelFor::errKernelLaunch, message];
   On[Parallel`Preferences`add::shdw,
      Parallel`Preferences`set::shdw,
      Parallel`Preferences`list::shdw,
      Parallel`Preferences`tr::shdw,
      Parallel`Protected`processes::shdw,
      SubKernels`Description::shdw];
   kernelName
];
LaunchSubkernelFor[message_String] :=
Module[{kernelName},
   kernelName = Utils`EvaluateOrQuit[
      LaunchKernels[1],
      LaunchSubkernelFor::errKernelLaunch, message];
   If[Head@kernelName === List, kernelName[[1]], kernelName]
];
LaunchSubkernelFor // Utils`MakeUnknownInputDefinition;
LaunchSubkernelFor ~ SetAttributes ~ {Locked,Protected};

CacheNameForMeta::usage=
"@brief Return the name of the cache file for given meta information
@param nPointMeta the given meta information
@returns the name of the cache file for given meta information.
";
CacheNameForMeta[nPointMeta:{__}] :=
   StringJoin["cache_",Riffle[ToString/@Flatten@nPointMeta, "_"],".m"];
CacheNameForMeta // Utils`MakeUnknownInputDefinition;
CacheNameForMeta ~ SetAttributes ~ {Locked,Protected};

CacheNPointFunction::usage=
"@brief Write a given n-point correlation function to the cache
@param nPointFunction the given n-point correlation function
@param cacheDir the directory to save cache
@param nPointMeta the meta information about the given n-point correlation
function";
CacheNPointFunction[nPointFunction_,cacheDir_,nPointMeta:{__}] :=
Module[
   {
      nPointFunctionsFile = FileNameJoin@{cacheDir,CacheNameForMeta@nPointMeta},
      fileHandle,
      nPointFunctions,
      position
   },
   If[FileExistsQ@nPointFunctionsFile,
      nPointFunctions = Get@nPointFunctionsFile,
      nPointFunctions = {}
   ];

   position = Position[nPointFunctions[[All,1]],nPointFunction[[1]]];
   If[Length@position === 1,
      nPointFunctions[[position[[1]]]] = nPointFunction,
      AppendTo[nPointFunctions, nPointFunction]
   ];

   fileHandle = OpenWrite@nPointFunctionsFile;
   Write[fileHandle,nPointFunctions];
   Close@fileHandle;
];
CacheNPointFunction // Utils`MakeUnknownInputDefinition;
CacheNPointFunction ~ SetAttributes ~ {Locked,Protected};

CachedNPointFunction::usage=
"@brief Retrieve an n-point correlation function from the cache
@param inFields the incoming fields of the n-point correlation function
@param outFields the outgoing fields of the n-point correlation function
@param cacheDir the directory to save cache
@param nPointMeta the meta information of the n-point correlation function
@returns the corresponding n-point correalation function from the
cache or `Null` if such a function could not be found.
";
CachedNPointFunction[inFields_,outFields_,cacheDir_,nPointMeta:{__}] :=
Module[
   {
      nPointFunctionsFile = FileNameJoin@{cacheDir,CacheNameForMeta@nPointMeta},
      nPointFunctions,
      position
   },
   If[!FileExistsQ@nPointFunctionsFile,Return@Null];
   nPointFunctions = Get@nPointFunctionsFile;
   position = Position[Vertices`StripFieldIndices[ nPointFunctions[[All,1]] ],
      {inFields, outFields}];
   If[Length@position == 1,nPointFunctions[[ position[[1,1]] ]],Null]
];
CachedNPointFunction // Utils`MakeUnknownInputDefinition;
CachedNPointFunction ~ SetAttributes ~ {Locked,Protected};

GenerateFAModelFileOnKernel::usage=
"@brief Generate the FeynArts model file on a given subkernel.";
GenerateFAModelFileOnKernel[kernel:_Parallel`Kernels`kernel|_KernelObject] :=
Module[
   {
      currentPath = $Path,
      currentDir = Directory[],
      fsMetaDir = FlexibleSUSY`$flexiblesusyMetaDir,
      sarahInputDirs = SARAH`SARAH@SARAH`InputDirectories,
      sarahOutputDir = SARAH`SARAH@SARAH`OutputDirectory,
      SARAHModelName = GetSARAHModelName[],
      eigenstates = FlexibleSUSY`FSEigenstates
   },
   DistributeDefinitions[currentPath, currentDir, fsMetaDir, sarahInputDirs,
      sarahOutputDir, SARAHModelName, eigenstates];

   ParallelEvaluate[
      $Path = currentPath;
      SetDirectory@currentDir;
      Get@FileNameJoin@{fsMetaDir, "NPointFunctions", "createFAModelFile.m"};
      NPointFunctions`CreateFAModelFile[sarahInputDirs,sarahOutputDir,
         SARAHModelName, eigenstates];,
      kernel];
];
GenerateFAModelFileOnKernel // Utils`MakeUnknownInputDefinition;
GenerateFAModelFileOnKernel ~ SetAttributes ~ {Locked,Protected};

WriteParticleNamespaceFile::usage=
"@brief Write a file containing all field names and the contexts in which they
live in Mathematica.
@note This is necessary because SARAH puts fields into different contexts.";
WriteParticleNamespaceFile[fileName_String] :=
Module[{fileHandle = OpenWrite@fileName},
   Write[fileHandle, {ToString@#, Context@#} & /@ TreeMasses`GetParticles[]];
   Close@fileHandle;
];
WriteParticleNamespaceFile // Utils`MakeUnknownInputDefinition;
WriteParticleNamespaceFile ~ SetAttributes ~ {Locked,Protected};

FANamesForFields::usage=
"@brief Translate SARAH-style fields to FeynArts-style fields
@param fields List of SARAH-style fields
@param particleNamesFile the path to the SARAH-created FeynArts
particle names file.
@returns A list of the FeynArts names (as strings) for the given
SARAH-style fields.";
FANamesForFields::errSARAH=
"NpointFunctions`.`Private`.`FANamesForFields[]: SARAH`.`:
It seems that SARAH`.` has changed conventions for
<ParticleNames>.dat file.";
FANamesForFields[fields_,particleNamesFile_String] :=
Module[
   {
      uniqueFields = DeleteDuplicates[
         CXXDiagrams`RemoveLorentzConjugation@# &/@ fields],
      faFieldNames
   },
   faFieldNames =
   Flatten[
      StringCases[Utils`ReadLinesInFile@particleNamesFile,
         ToString@# ~~ ": " ~~ x__ ~~ "]" ~~ ___ :> "FeynArts`" <> x <> "]"
      ] & /@ uniqueFields
   ];
   Utils`AssertWithMessage[Length@faFieldNames > 0,
      FANamesForFields::errSARAH];

   fields /. MapThread[Rule, {uniqueFields, faFieldNames}] /.
      {
         SARAH`bar@field_String :> "-" <> field,
         Susyno`LieGroups`conj@field_String :> "-" <> field
      }
];
FANamesForFields // Utils`MakeUnknownInputDefinition;
FANamesForFields ~ SetAttributes ~ {Locked,Protected};

RemoveEmptyGenSums::usage=
"@brief Sometimes after FA+FC calculation some generic sums are empty. This
means that one can simply remove them (as well as corresponding
colour/combinatoric factors and field substitution rules). This work is done by
this function.
@param npfObject NPF object to clean.
@returns cleaned from empty GenericSums npfObject.";
RemoveEmptyGenSums[npfObject:`type`npf]:=npfObject;
RemoveEmptyGenSums[
   {fields:{{__},{__}},
      {
         {
            sums:{GenericSum[_,{___}]..},
            rules:{{{__}..}..},
            comb:{{__Integer}..},
            col:{{__}..}
         },
         subs:{Rule[_,_]...}
      }
   }]:=
Module[{poss=Position[sums,GenericSum[{0},{}]]},
   Print["Removing zero GenericSum at positions ",
      StringRiffle[ToString/@Flatten@poss,", "],"."];
   {fields,{Delete[#,poss]&/@{sums,rules,comb,col},subs}}
];
RemoveEmptyGenSums // Utils`MakeUnknownInputDefinition;
RemoveEmptyGenSums ~ SetAttributes ~ {Locked,Protected};

CreateCXXHeaders::usage=
"@brief Create the c++ code for the necessary headers.
@returns The c++ code for the necessary headers.";
CreateCXXHeaders[] :=
replaceTokens["
   #include \"loop_libraries/loop_library.hpp\"
   #include \"cxx_qft/@ModelName@_npointfunctions_wilsoncoeffs.hpp\"
   #include \"concatenate.hpp\"
   #include <limits>
   #include <boost/fusion/include/at_key.hpp>
   #include <boost/core/is_same.hpp>",
   {
      "@ModelName@"->FlexibleSUSY`FSModelName
   }
];
CreateCXXHeaders // Utils`MakeUnknownInputDefinition;
CreateCXXHeaders ~ SetAttributes ~ {Locked,Protected};

CreateCXXFunctions::usage=
"@brief Given a list of n-point correllation functions, a list
of c++ function names and a list of colour factor projections
create the c++ code for the numerical evaluation of the
n-point correllation functions.
@param npf n-point correlation function object.
@param name function name
@param colourProjector Colour projection function that represents color structure
of ampitudes.
@param wilsonBasis Basis for matching.
@returns a list of the form `{prototypes, definitions}` containing
the corresponding c++ code.";
CreateCXXFunctions::errNoMatch=
"Length of basis and the given NPF one does not match."
CreateCXXFunctions[
   npf:`type`npf,
   name:_String,
   colourProjector:`type`colourProjector,
   wilsonBasis:`type`wilsonBasis:{"value"->"dummy string"}
] :=
Module[
   {
      mainFunction = "std::array<std::complex<double>,"<>`cxx`getLength@wilsonBasis<>"> "<>name<>"("<>#<>")"&,
      prototype,definition
   },
   `current`setHelperClassName@npf;
   `current`setWilsonBasis@wilsonBasis;

   prototype = mainFunction@`cxx`arguments[npf,Default]<>";";

   definition =
      `cxx`npfClass[applySubexpressions@npf,colourProjector] <> "\n\n" <>
      mainFunction@`cxx`arguments@npf <>
      "{\n   "<>`current`helperClassName<>" helper{ model, indices, momenta };\n   return helper.calculate();\n}";

   {prototype, definition}
] /;
And@@(Utils`AssertOrQuit[Length@wilsonBasis === Length@#,CreateCXXFunctions::errNoMatch]&/@getExpression/@getGenericSums@npf);
CreateCXXFunctions // Utils`MakeUnknownInputDefinition;
CreateCXXFunctions ~ SetAttributes ~ {Locked,Protected};

`cxx`arguments::usage=
"@brief Returns the c++ arguments that the c++ version of the given n-point
correlation function shall take.
Default value of zero for all external momenta is chosen if the second parameter
is Default.
@param npf The given n-point correlation function
@param control String that sets up the type of argument string
@return the c++ arguments that the c++ version of the given n-point
correlation function shall take.";
`cxx`arguments[npf:`type`npf,control:Null|Default:Null] :=
   "const "<>#1<>" &model,"<>
   " const std::array<int,"<>#2<>"> &indices,"<>
   " const std::array<Eigen::Vector4d,"<>#3<>"> &momenta"<>
   If[control === Default," = { "<>#4<>" }",""]& [
      FlexibleSUSY`FSModelName<>"_mass_eigenstates",
      ToString@Length@getExternalIndices@npf,
      ToString@#,
      Utils`StringJoinWithReplacement@Array["Eigen::Vector4d::Zero()",#]
   ] &@ Length@getExternalMomenta@npf;
`cxx`arguments // Utils`MakeUnknownInputDefinition;
`cxx`arguments ~ SetAttributes ~ {Locked,Protected};

`current`wilsonBasis = {"value"->"dummy string"};
`current`wilsonBasis ~ SetAttributes ~ {Protected};

`current`setWilsonBasis[obj:`type`wilsonBasis] :=
(
   Unprotect[`current`wilsonBasis];
   `current`wilsonBasis = obj;
   Protect[`current`wilsonBasis];
);
`current`setWilsonBasis // Utils`MakeUnknownInputDefinition;
`current`setWilsonBasis ~ SetAttributes ~ {Locked,Protected};

`current`helperClassName = "";
`current`helperClassName ~ SetAttributes ~ {Protected};

`current`setHelperClassName::usage=
"@brief Sets the c++ name for the helper class of the c++
version of a given n-point correlation function.
@param obj NPointFunction object
@returns the c++ name for the helper class of the c++ version of a given n-point
correlation function.";
`current`setHelperClassName[obj:`type`npf] :=
Module[{fieldNames = Vertices`StripFieldIndices/@Join@@getProcess[obj]},
   Unprotect@`current`helperClassName;
   `current`helperClassName = "nPoint" <> StringJoin@Map[ToString,fieldNames/.a_[b_]:>Sequence@@{a,b}] <> "_" <> ToString@Ceiling[10^6*AbsoluteTime[]];
   Protect@`current`helperClassName;
];
`current`setHelperClassName // Utils`MakeUnknownInputDefinition;
`current`setHelperClassName ~ SetAttributes ~ {Locked,Protected};

`cxx`npfClass::usage=
"@brief Return the c++ code for the helper class of the c++ version of a given
n-point correlation function.
@param npf The given n-point correlation function.
@param projCol The colour factor projection to be applied for the
given n-point correlation function.
@returns The c++ code for the helper class of the c++ version of a given
n-point correlation function.";
`cxx`npfClass[npf:`type`npf, projCol:`type`colourProjector] :=
Module[
   {
      genSums = getGenericSums@npf,
      extIndices = getExternalIndices@npf,
      numberOfMomenta = Length[getExternalMomenta@npf],
      genFields = DeleteDuplicates[Flatten@getClassFieldRules@npf /. Rule[x_,_] :> x],
      genSumNames,
      code = "
      class @ClassName@ : public @Context@
      {
         using generic_sum_base = @Context@;

         template<class GenericFieldMap>
         struct subexpression_base :
         generic_sum_base, index_map_interface<GenericFieldMap>
         {
            subexpression_base( const subexpression_base & ) = default;

            subexpression_base( const generic_sum_base &gsb,
               const typename field_index_map<GenericFieldMap>::type &fim ) :
            generic_sum_base( gsb ), index_map_interface<GenericFieldMap>( fim )
            {}
         }; // End of subexpression_base<GenericFieldMap>

         @KeyStructsInitialization@

         @GenericSums@

         public:
         @ClassName@( @Arguments@ ) :
         @Context@ { model, indices, momenta }
         {}

         @CalculateFunction@
      }; // End of @ClassName@"
   },
   genSumNames = Array["genericSum"<>ToString@#&,Length@genSums];
   `current`setCxxRules[extIndices,genFields];

   replaceTokens[code,{
   "@ClassName@"->`current`helperClassName,
   "@Context@"->"correlation_function_context<"<>ToString@Length@extIndices<>","<>ToString@numberOfMomenta<>">",
   "@KeyStructsInitialization@"->`cxx`initializeKeyStructs@genFields,
   "@GenericSums@"->`cxx`genericSum[npf,projCol,genSumNames],
   "@Arguments@"->`cxx`arguments@npf,
   "@CalculateFunction@"->`cxx`calculateFunction@genSumNames}]
];
`cxx`npfClass // Utils`MakeUnknownInputDefinition;
`cxx`npfClass ~ SetAttributes ~ {Locked,Protected};

`cxx`initializeKeyStructs::usage =
"@brief Generates required c++ code for key structs initialization.
@param fields List of generic fields.
@returns c++ code for subexpression if generic fields present there.";
`cxx`initializeKeyStructs[fields:{`type`genericField..}]:=
   StringRiffle["struct "<>#<>" {};"&/@`cxx`genericFieldKey/@fields,"\n"];
`cxx`initializeKeyStructs // Utils`MakeUnknownInputDefinition;
`cxx`initializeKeyStructs ~ SetAttributes ~ {Locked,Protected};

`current`cxxRules = {{}};
`current`cxxRules ~ SetAttributes ~ {Protected};

`current`setCxxRules::usage=
"@brief Generate a list of rules for translating Mathematica expressions of
n-point correlation functions to c++ ones.
@param extIndices The external indices of an n-point correlation function.
@param genericFields The generic fields appearing in an n-point correlation function.
@returns a list of rules for translating Mathematica expressions of n-point
correlation functions to c++ ones.";
`current`setCxxRules[extIndices:{___Symbol},genericFields:{`type`genericField..}] :=
Module[
   {
      externalIndexRules = MapThread[Rule,{extIndices,
         Array["this->external_indices("<>ToString[#-1]<>")"&,Length@extIndices]}],
      AuxVertexType,
      genericRules,massRules,couplingRules
   },
   genericRules=Flatten[Thread@Rule[
      {getConjugated[#],#},
      {
         cxxName[getConjugated@#][cxxIndex@#],
         cxxName[#][cxxIndex@#]
      }] &/@ genericFields];

   AuxVertexType[fields__]:= StringRiffle[
      If[MatchQ[#,`type`genericField],
         cxxName@#,
         `cxx`fieldName@#]&/@{fields},", "];
   couplingRules = {
      SARAH`Cp[fields__][1] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_scalar{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[`cxx`fieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][SARAH`PL] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_left{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[`cxx`fieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][SARAH`PR] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_right{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[`cxx`fieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields___][SARAH`Mom[f1_] - SARAH`Mom[f2_]] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_momentum_diff{`2`,`3`}, concatenate(`4`))"][
         AuxVertexType@fields,
         First@@Position[{fields},f1,{1}]-1,                                    (*@note hope that nobody call particle List*)
         First@@Position[{fields},f2,{1}]-1,                                    (*@note hope that nobody call particle List*)
         StringRiffle[`cxx`fieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][SARAH`g[_,_]] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_inverse_metric{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[`cxx`fieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][(SARAH`Mom[f2_, _]-SARAH`Mom[f1_, _])*SARAH`g[_,_],
         (SARAH`Mom[f1_,_]-SARAH`Mom[f3_,_])*SARAH`g[_,_],
         (SARAH`Mom[f3_,_]-SARAH`Mom[f2_,_])*SARAH`g[_,_]] :>
      I*StringTemplate["context.vertex<`1`>(triple_vector{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[`cxx`fieldIndices/@{fields},", "]
         ]
   };
   massRules =
   {
      SARAH`Mass[genField_String[genIndex_String]] :>
      "context.mass<"<>genField<>">("<>genIndex<>")",

      SARAH`Mass[extField_Symbol[{extIndex_String}]] :>
      "context.mass<fields::"<>ToString@extField<>">(std::array<int,1> {"<>extIndex<>"})",

      SARAH`Mass[extField_Symbol] :>
      "context.mass<fields::"<>ToString@extField<>">(std::array<int,0> {})"
   };

   Unprotect@`current`cxxRules;
   `current`cxxRules={externalIndexRules,couplingRules,genericRules,massRules};
   Protect@`current`cxxRules;
];
`current`setCxxRules // Utils`MakeUnknownInputDefinition;
`current`setCxxRules ~ SetAttributes ~ {Locked,Protected};

`current`applyCxxRules[obj_] :=
Parameters`ExpressionToString[Fold[ReplaceAll,obj,`current`cxxRules]];
`current`applyCxxRules // Utils`MakeUnknownInputDefinition;
`current`applyCxxRules ~ SetAttributes ~ {Locked,Protected};

`cxx`fieldName::usage =
"@brief Given an explicit field (possibly conjugated), returns its c++ representation.
@param The given generic field
@returns String Name of the c++ representation for a field (possibly conjugate).";
`cxx`fieldName[SARAH`bar[head_]] :=
   StringJoin["typename bar<",`cxx`fieldName@head,">::type"];
`cxx`fieldName[Susyno`LieGroups`conj[head_]] :=
   StringJoin["typename conj<",`cxx`fieldName@head,">::type"]
`cxx`fieldName[fieldName_Symbol[_?VectorQ] | fieldName_Symbol] :=
   StringJoin["fields::",SymbolName@fieldName];
`cxx`fieldName // Utils`MakeUnknownInputDefinition;
`cxx`fieldName ~ SetAttributes ~ {Locked,Protected};

`cxx`fieldIndices::usage=
"@brief Return the c++ expression for the given field.
@param field The given field
@returns The c++ expression for the given field.
@note function saves its previous calls to improve the speed.";
`cxx`fieldIndices[SARAH`bar[field_]] := `cxx`fieldIndices[SARAH`bar[field]] =
   `cxx`fieldIndices@field;
`cxx`fieldIndices[Susyno`LieGroups`conj[field_]] := `cxx`fieldIndices[Susyno`LieGroups`conj[field]] =
   `cxx`fieldIndices@field;
`cxx`fieldIndices[head_[GenericIndex[index_Integer]]] := `cxx`fieldIndices[head[GenericIndex[index]]] =
   "indices"<>StringTake[SymbolName@head,-1]<>ToString@index;
`cxx`fieldIndices[field_] := `cxx`fieldIndices[field] =
If[Length@field === 0,
   "std::array<int,0>()",
   "std::array<int,1>{"<>ToString@First@field<>"}"
];
`cxx`fieldIndices // Utils`MakeUnknownInputDefinition;
`cxx`fieldIndices ~ SetAttributes ~ {Locked};

`cxx`genericFieldKey::usage=
"@brief Given a generic field(s), determine its key type used in the c++ code to
uniquely label it.
@param genericField given generic field.
@param {genericField..} given generic fields.
@returns c++ key type of a generic field(s).";
`cxx`genericFieldKey[fields:{__}] :=
   StringRiffle[`cxx`genericFieldKey/@fields,", "];
`cxx`genericFieldKey[head_[GenericIndex[index_Integer]]] :=
   ToString@head<>ToString@index<>"Key";
`cxx`genericFieldKey // Utils`MakeUnknownInputDefinition;
`cxx`genericFieldKey ~ SetAttributes ~ {Locked,Protected};

getColourFactor::usage=
"@brief Extracts the colour factor for a given colour structure.";
getColourFactor::errMultipleColourStructures=
"There are different colour projectors inside colour factors:
`1`.";
getColourFactor::errNotNumber=
"After projection element
`1`
still is not a number."
getColourFactor::warnTryingIdentity=
"Warning: There are no colour projectors of the given type. Trying to apply Identity."
getColourFactor[colourfactors:{`type`classColorFactors..}, projection:`type`colourProjector] :=
Module[
   {
      projectedFactors,uniqueColourStructs
   },
   projectedFactors=
   If[projection === Identity,
      colourfactors,
      uniqueColourStructs=DeleteDuplicates@Cases[colourfactors,projection[__],Infinity];
      Utils`AssertOrQuit[Length@uniqueColourStructs<=1,getColourFactor::errMultipleColourStructures,uniqueColourStructs];
      If[Length@uniqueColourStructs===0,
         Print[getColourFactor::warnTryingIdentity];
         colourfactors,
         colourfactors/.Rule[uniqueColourStructs[[1]],1]
         ]
      ];
   Utils`AssertOrQuit[NumericQ@#,getColourFactor::errNotNumber,#]&/@Flatten[projectedFactors,2];

   projectedFactors
];
getColourFactor // Utils`MakeUnknownInputDefinition;
getColourFactor ~ SetAttributes ~ {Locked,Protected};

`cxx`genericSum::usage=
"@brief Create the c++ code form of a generic sums.
@param obj nPointFunction object.
@param colourProjector
@param genSumNames Set of names for generic sums.";
`cxx`genericSum::errColours=
"Colour factor is not a number after projection: `1`";
`cxx`genericSum[
   obj:`type`npf,
   colourProjector:`type`colourProjector,
   genSumNames:{__String}
] :=
StringRiffle[MapThread[
   `cxx`genericSum[##,getSubexpressions@obj]&,
      {
         getGenericSums@obj,
         getClassFields@obj,
         getClassCombinatoricalFactors@obj,
         getColourFactor[getClassColorFactors@obj,colourProjector],
         genSumNames
      }
   ],
"\n\n"];
`cxx`genericSum[
   sum:`type`genericSum,
   genericInsertions:`type`classFields,
   combinatorialFactors:`type`classCombinatoricalFactors,
   colourFactors:{__?NumericQ},
   genSumName_String,
   subexpressions:`type`subexpressions
] :=
Module[
   {
      code = "
      template<class GenericFieldMap>
      struct @GenericSum_NAME@_impl : generic_sum_base {
         @GenericSum_NAME@_impl( const generic_sum_base &base ) :
         generic_sum_base( base ) {
         } // End of constructor @GenericSum_NAME@_impl

         std::array<std::complex<double>,@WilsonBasisLength@> operator()( void ) {
            using boost::mpl::at;
            using boost::fusion::at_key;
            @GenericFieldShortNames@

            typename field_index_map<GenericFieldMap>::type index_map;
            const context_with_vertices &context = *this;
            @InitializeOutputVars@

            @SummationOverGenericFields@

            return @ReturnOutputVars@;
         } // End of operator()( void )
      }; // End of struct @GenericSum_NAME@_impl<GenericFieldMap>

      std::array<std::complex<double>,@WilsonBasisLength@> @GenericSum_NAME@( void ) {
         using GenericKeys = boost::mpl::vector< @GenericKeys@ >;
         using GenericInsertions = boost::mpl::vector<
            @ClassInsertions@
            >;
         using combinatorial_factors = boost::mpl::vector<
            @CombinatoricalFactors@
            >;
         using colour_factors = boost::mpl::vector<
            @ColorFactors@
            >;
         return accumulate_generic<
            GenericKeys,
            GenericInsertions,
            combinatorial_factors,
            colour_factors,
            boost::mpl::int_<@WilsonBasisLength@>,
            @GenericSum_NAME@_impl
            >( *this );
      } // End of function @GenericSum_NAME@()"
   },
   replaceTokens[code,
      {
         "@GenericSum_NAME@"->genSumName,
         "@GenericFieldShortNames@"->`cxx`shortNames@getGenericFields@sum,
         "@InitializeOutputVars@"->StringRiffle["std::complex<double> "<>#<>" = 0.0;"&/@First/@`current`wilsonBasis,"\n"],
         "@SummationOverGenericFields@"->`cxx`changeGenericExpressions[getSummationData@sum,getExpression@sum],
         "@ReturnOutputVars@"->ToString[First/@`current`wilsonBasis],
         "@GenericKeys@"->`cxx`genericFieldKey@getGenericFields@sum,
         "@ClassInsertions@"->`cxx`insertFields@genericInsertions,
         "@CombinatoricalFactors@"->`cxx`insertFactors@combinatorialFactors,
         "@ColorFactors@"->`cxx`insertColours@colourFactors,
         "@WilsonBasisLength@"->`cxx`getLength@`current`wilsonBasis
      }
   ]
];
`cxx`genericSum // Utils`MakeUnknownInputDefinition;
`cxx`genericSum ~ SetAttributes ~ {Locked,Protected};

`cxx`changeGenericExpressions::usage =
"@brief Generates c++ code for output value updating inside generic sum.
@param summation Summation structure of generic index.
@param expr List of expressions to be converted into c++ code.
@returns c++ code for output value initializations inside generic sum.";
`cxx`changeGenericExpressions::errUnimplementedLoops =
"Unsupported loop functions
`1`
were detected.";
`cxx`changeGenericExpressions[summation:`type`summation, expr:{__}] :=
Module[
   {
      code ="
      // The following definitions are repeated in the GenericSum multiple times.
      @defineMasses@
      @defineCouplings@
      @defineLoopFunctions@

      // Start of summation over generic fields.
      @BeginSum@
         @setMasses@
         @setCouplings@
         @skipZeroAmplitude@
         @setLoopFunctions@
         @ChangeOutputValues@
      @EndSum@",
      modifiedExpr = expr,
      masses,massDefine,codeMass,massRules,
      couplings,couplingDefile,codeCoupling,couplingRules,
      loopRules,loopArrayDefine,loopArraySet,
      cxxExpr,updatingVars
   },
   masses = Tally@Cases[modifiedExpr,_SARAH`Mass,Infinity,Heads->True];
   {massDefine,codeMass,massRules} = createUniqueDefinitions[masses,{"double","m"}];
   modifiedExpr = modifiedExpr /. massRules;

   couplings = Tally@Cases[modifiedExpr,SARAH`Cp[__][___],Infinity,Heads->True];
   {couplingDefile,codeCoupling,couplingRules} = createUniqueDefinitions[couplings,{"std::complex<double>","g"}];
   modifiedExpr = modifiedExpr /. couplingRules;

   {loopRules,loopArrayDefine,loopArraySet,modifiedExpr} = createLoopFunctions@modifiedExpr;

   cxxExpr = `current`applyCxxRules/@modifiedExpr;
   cxxExpr = StringReplace[#, "\"" -> ""]&/@cxxExpr;
   updatingVars = MapThread[#1<>" += "<>#2<>";"&, {First/@`current`wilsonBasis, cxxExpr}];

   replaceTokens[code,{
      "@defineMasses@"->massDefine,
      "@defineCouplings@"->couplingDefile,
      "@defineLoopFunctions@"->loopArrayDefine,
      "@BeginSum@"->`cxx`beginSum@summation,
      "@setMasses@"->codeMass,
      "@setCouplings@"->codeCoupling,
      "@skipZeroAmplitude@"->`cxx`skipZeroAmplitude[modifiedExpr,loopRules,massRules],
      "@setLoopFunctions@"->loopArraySet,
      "@ChangeOutputValues@"->StringRiffle[updatingVars,"\n"],
      "@EndSum@"->`cxx`endSum@getGenericFields@summation
   }]
];
`cxx`changeGenericExpressions // Utils`MakeUnknownInputDefinition;
`cxx`changeGenericExpressions ~ SetAttributes ~ {Locked,Protected};

createLoopFunctions[modifiedExpr:{__}] :=
Module[
   {
      onePoint,
      onePointTemplate =
         {
            LoopTools`A0@@#2 -> "a"<>#1<>".at(0)",
            LoopTools`A0i[LoopTools`aa0,Sequence@@#2] -> "a"<>#1<>".at(0)"
         }&,

      twoPoint,
      twoPointTemplate =
         {
            LoopTools`B0@@#2 -> "b"<>#1<>".at(0)",
            LoopTools`B1@@#2 -> "b"<>#1<>".at(1)",
            LoopTools`B00@@#2 -> "b"<>#1<>".at(2)",
            LoopTools`B0i[LoopTools`bb0,Sequence@@#2] -> "b"<>#1<>".at(0)",
            LoopTools`B0i[LoopTools`bb1,Sequence@@#2] -> "b"<>#1<>".at(1)",
            LoopTools`B0i[LoopTools`bb00,Sequence@@#2] -> "b"<>#1<>".at(2)"
         }&,

      threePoint,
      threePointTemplate =
         {
            LoopTools`C0@@#2 -> "c"<>#1<>".at(0)",
            LoopTools`C0i[LoopTools`cc0,Sequence@@#2] -> "c"<>#1<>".at(0)",
            LoopTools`C0i[LoopTools`cc1,Sequence@@#2] -> "c"<>#1<>".at(1)",
            LoopTools`C0i[LoopTools`cc2,Sequence@@#2] -> "c"<>#1<>".at(2)",
            LoopTools`C0i[LoopTools`cc00,Sequence@@#2] -> "c"<>#1<>".at(3)",
            LoopTools`C0i[LoopTools`cc11,Sequence@@#2] -> "c"<>#1<>".at(4)",
            LoopTools`C0i[LoopTools`cc12,Sequence@@#2] -> "c"<>#1<>".at(5)",
            LoopTools`C0i[LoopTools`cc22,Sequence@@#2] -> "c"<>#1<>".at(6)"
         }&,

      fourPoint,
      fourPointTemplate =
         {
            LoopTools`D0@@#2 -> "d"<>#1<>".at(0)",
            LoopTools`D0i[LoopTools`dd0,Sequence@@#2] -> "d"<>#1<>".at(0)",
            LoopTools`D0i[LoopTools`dd1,Sequence@@#2] -> "d"<>#1<>".at(1)",
            LoopTools`D0i[LoopTools`dd2,Sequence@@#2] -> "d"<>#1<>".at(2)",
            LoopTools`D0i[LoopTools`dd3,Sequence@@#2] -> "d"<>#1<>".at(3)",
            LoopTools`D0i[LoopTools`dd00,Sequence@@#2] -> "d"<>#1<>".at(4)",
            LoopTools`D0i[LoopTools`dd11,Sequence@@#2] -> "d"<>#1<>".at(5)",
            LoopTools`D0i[LoopTools`dd12,Sequence@@#2] -> "d"<>#1<>".at(6)",
            LoopTools`D0i[LoopTools`dd13,Sequence@@#2] -> "d"<>#1<>".at(7)",
            LoopTools`D0i[LoopTools`dd22,Sequence@@#2] -> "d"<>#1<>".at(8)",
            LoopTools`D0i[LoopTools`dd23,Sequence@@#2] -> "d"<>#1<>".at(9)",
            LoopTools`D0i[LoopTools`dd33,Sequence@@#2] -> "d"<>#1<>"[10]"
         }&,

      append,
      loopRules = {},
      loopArrayDefine = {},
      loopArraySet = {}
   },
   Utils`AssertOrQuit[#==={},`cxx`changeGenericExpressions::errUnimplementedLoops,Utils`StringJoinWithSeparator[#,", "]] &@
      DeleteDuplicates@Cases[modifiedExpr,Alternatives[
      _LoopTools`A00,
      _LoopTools`B00,_LoopTools`B11,_LoopTools`B001,_LoopTools`B111,
      _LoopTools`DB0,_LoopTools`DB1,
      _LoopTools`DB00,_LoopTools`DB11,
      _LoopTools`E0i,_LoopTools`E0,
      _LoopTools`F0i,_LoopTools`F0],Infinity,Heads->True];
   append[loopFunctions_List,function_,functionName_String,arrayName_String] := If[loopFunctions=!={},
      AppendTo[loopArrayDefine,Array[
         "looplibrary::"<>functionName<>"coeff_t "<>arrayName<>ToString@#<>"{}"&,
         Length@loopFunctions]
      ];
      AppendTo[loopArraySet,Array[
         Parameters`ExpressionToString[StringJoin["Loop_library::get().",functionName][arrayName<>ToString@#,Sequence@@loopFunctions[[#,1]],"Sqr(context.scale())"]]<>
         "; // It is repeated "<>ToString@loopFunctions[[#,2]]<>" times."&,
         Length@loopFunctions]
      ];
      AppendTo[loopRules,Join@@function@@@Array[{ToString@#,loopFunctions[[#,1]]}&,Length@loopFunctions]];
   ];

   onePoint = Tally@Join[
      Cases[modifiedExpr,LoopTools`A0i[_,args:__]:>{args},Infinity],
      Cases[modifiedExpr,LoopTools`A0[args:__]:>{args},Infinity]
   ];

   twoPoint = Tally@Join[
      Cases[modifiedExpr,LoopTools`B0i[_,args:__]:>{args},Infinity],
      Cases[modifiedExpr,(LoopTools`B0|LoopTools`B0)[args:__]:>{args},Infinity]
   ];

   threePoint = Tally@Join[
      Cases[modifiedExpr,LoopTools`C0i[_,args:__]:>{args},Infinity],
      Cases[modifiedExpr,(LoopTools`C0)[args:__]:>{args},Infinity]
   ];

   fourPoint = Tally@Join[
      Cases[modifiedExpr,LoopTools`D0i[_,args:__]:>{args},Infinity],
      Cases[modifiedExpr,(LoopTools`D0)[args:__]:>{args},Infinity]
   ];

   append[onePoint,onePointTemplate,"A","a"];
   append[twoPoint,twoPointTemplate,"B","b"];
   append[threePoint,threePointTemplate,"C","c"];
   append[fourPoint,fourPointTemplate,"D","d"];

   {
      Flatten@loopRules,
      Utils`StringJoinWithSeparator[Join@@loopArrayDefine,";\n"]<>";\n",
      Utils`StringJoinWithReplacement[Join@@loopArraySet,"\n","\""->""],
      modifiedExpr/.Flatten@loopRules
   }
];
createLoopFunctions // Utils`MakeUnknownInputDefinition;
createLoopFunctions ~ SetAttributes ~ {Locked,Protected};

`cxx`skipZeroAmplitude[modifiedExpr:{__},loopRules:{Rule[_,_]..},massRules:{Rule[_,_]..}] :=
Module[
   {
      numbersToOne = {_Integer->1,_Rational->1,_Complex->1,Pi->1},
      massesToOne = Rule[#,1] & /@ massRules[[All,2]],
      loopsToOne = Rule[#,1] & /@ loopRules[[All,2]],
      result
   },
   result=ExpandAll[modifiedExpr]/.numbersToOne/.Plus->List/.massesToOne/.loopsToOne;
   result = DeleteDuplicates[Flatten@DeleteCases[result,1]];
   If[ 1 === Length@result,
      result = "std::abs"@@result,
      result = Plus@@(result/.HoldPattern[Times[x__]]:>Times@@("std::abs"@#&/@{x}))
   ];
   "if( "<>StringReplace[Parameters`ExpressionToString@result,"\""->""]<>" < std::numeric_limits<double>::epsilon() ) continue;"
];
`cxx`skipZeroAmplitude // Utils`MakeUnknownInputDefinition;
`cxx`skipZeroAmplitude ~ SetAttributes ~ {Locked,Protected};

`cxx`getVariableName[SARAH`Mass[obj:`type`genericField]] :=
`cxx`getVariableName[SARAH`Mass[obj]] =
Switch[getName@obj,GenericS,"mS",GenericF,"mF",GenericV,"mV",GenericU,"mU"]<>ToString@getIndex@obj;
`cxx`getVariableName[SARAH`Mass[obj:`type`physicalField]] :=
`cxx`getVariableName[SARAH`Mass[obj]] =
"m"<>ToString@getName@obj<>`cxx`getIndex@obj;
`cxx`getVariableName // Utils`MakeUnknownInputDefinition;
`cxx`getVariableName ~ SetAttributes ~ {Locked,Protected};

createUniqueDefinitions[expr:{{_,_Integer}..},{type_String,name_String}] :=
Module[{names,namedExpr,code,rules},
   namedExpr = Array[
      {
         name<>ToString@#,
         `current`applyCxxRules@expr[[#,1]],
         expr[[#,1]],
         expr[[#,2]]
      }&,
      Length@expr
   ];
   names = type<>" "<>StringRiffle[First/@namedExpr,", "]<>";";
   code = StringRiffle[#1<>" = "<>#2<>"; // It is repeated "<>ToString@#4<>" times."&@@@namedExpr,"\n"];
   rules = Rule@@@namedExpr[[All,{3,1}]];
   {names,StringReplace[code,"\""->""],rules}
];
createUniqueDefinitions // Utils`MakeUnknownInputDefinition;
createUniqueDefinitions ~ SetAttributes ~ {Locked,Protected};

`cxx`shortNames::usage =
"@brief Generates c++ code for type abbreviations stored in GenericFieldMap
(Associative Sequence) at Key positions.
@param genFields List of generic fields.
@returns String c++ code for type abbreviations stored in GenericFieldMap
(Associative Sequence) at Key positions.";
`cxx`shortNames[genFields:{`type`genericField..}] :=
   StringRiffle[Apply[
      "using "<>ToString@#1<>" = typename at<GenericFieldMap,"<>ToString@#2<>">::type;"&,
      {cxxName@#,`cxx`genericFieldKey@#}&/@genFields,
      {1}],"\n"];
`cxx`shortNames // Utils`MakeUnknownInputDefinition;
`cxx`shortNames ~ SetAttributes ~ {Locked,Protected};

`cxx`beginSum::usage =
"@brief Generates c++ code for sum beginning used inside GenericSum.
@param <{{generic field, restriction}..}> summation List of generic index
restriction rules pares, which, if are true should lead to a skip of summation.
@returns String c++ code for sum beginning used inside generic sums.";
`cxx`beginSum[summation:`type`summation]:=
Module[{beginsOfFor},
   beginsOfFor =
      "for( const auto &"<>cxxIndex[#[[1]]]<>" : "<>"index_range<"<>cxxName[#[[1]]]<>">() ) {\n"<>
      "at_key<"<>`cxx`genericFieldKey@#[[1]]<>">( index_map ) = "<>cxxIndex[#[[1]]]<>";"<>parseRestrictionRule[#] &/@summation;
   StringRiffle[beginsOfFor,"\n"]
];
`cxx`beginSum // Utils`MakeUnknownInputDefinition;
`cxx`beginSum ~ SetAttributes ~ {Locked,Protected};

parseRestrictionRule[{genericField:`type`genericField,rule_}] :=
Module[{f1,f2,getIndexOfExternalField,OrTwoDifferent},
   getIndexOfExternalField[_[_[{ind_}]]] := "std::array<int,1> {"<>`current`applyCxxRules@ind<>"}";
   getIndexOfExternalField[_[{ind_}]] := "std::array<int,1> {"<>`current`applyCxxRules@ind<>"}";
   getIndexOfExternalField[_] := "std::array<int,0> {}";

   OrTwoDifferent[] := Module[
      {
         type1 = `cxx`fieldName@First@rule,
         type2 = `cxx`fieldName@Last@rule,
         ind = getIndexOfExternalField@First@rule,
         typeGen = cxxName@genericField,
         indGen = cxxIndex@genericField
      },
      "\nif( (boost::core::is_same<"<>typeGen<>","<>type1<>">::value || boost::core::is_same<"<>typeGen<>","<>type2<>">::value) && "<>indGen<>" == "<>ind<>" ) continue;"
   ];

   Switch[rule,
      Or[f1_,f2_],OrTwoDifferent[],
      False,"",
      _,"@todo This rule is ununderstandable!";Quit[1]]
];
parseRestrictionRule // Utils`MakeUnknownInputDefinition;
parseRestrictionRule ~ SetAttributes ~ {Locked,Protected};

`cxx`endSum::usage =
"@brief Generates c++ code for end of sum over generic fields inside GenericSum.
@param genFields List of generic fields.
@returns String c++ code for end of sum over generic fields inside GenericSum.";
`cxx`endSum[genFields:{`type`genericField..}] :=
   StringJoin[
      Array["}"&,Length@genFields],
      " // End of summation over generic fields"];
`cxx`endSum // Utils`MakeUnknownInputDefinition;
`cxx`endSum ~ SetAttributes ~ {Locked,Protected};

`cxx`calculateFunction::usage =
"@brief Generates c++ code for functions which return result of generic sum
calculation.
@param genSumNames list of strings with names of generic sums.
@returns String Generates c++ code for functions which return result of generic sum
calculation.";
`cxx`calculateFunction[genSumNames:{__String}] :=
Module[
   {
      varName = "genericsum" (* Feel free to change me to another c++ name *),
      varNames,initVars,sumOfSums
   },
   varNames = Array[varName<>ToString@#&,Length@genSumNames];
   initVars = MapThread["const auto "<>#1<>" = "<>#2<>"();"&,{varNames,genSumNames}]~StringRiffle~"\n";
   sumOfSums = StringRiffle[#<>".at(i)"&/@varNames,"+"];
   replaceTokens["
   std::array<std::complex<double>,@BasisLength@> calculate( void ) {
      std::array<std::complex<double>,@BasisLength@> genericSummation;
      constexpr int coeffsLength = genericSummation.size();
      @InitializeVariablesWhichStoreGenericSumsOutput@

      for ( std::size_t i=0; i<coeffsLength; i++ ) {
         genericSummation.at(i) += @SumOfVariables@;
      }
      return genericSummation;
   } // End of calculate()",
   {
      "@BasisLength@"->`cxx`getLength@`current`wilsonBasis,
      "@InitializeVariablesWhichStoreGenericSumsOutput@"->initVars,
      "@SumOfVariables@"->sumOfSums
   }]
];
`cxx`calculateFunction // Utils`MakeUnknownInputDefinition;
`cxx`calculateFunction ~ SetAttributes ~ {Locked,Protected};

`cxx`insertFields::usage =
"@brief Generates c++ code for class insertions inside GenericSum.
@param genInsertions list of list with SARAH particle names.
@returns String c++ code for class insertions inside GenericSum.";
`cxx`insertFields[genInsertions:`type`classFields] :=
   StringRiffle["boost::mpl::vector<"<>StringRiffle[`cxx`fieldName@#&/@#,", "]<>">"&/@genInsertions,",\n"];
`cxx`insertFields // Utils`MakeUnknownInputDefinition;
`cxx`insertFields ~ SetAttributes ~ {Locked,Protected};

`cxx`insertFactors::usage =
"@brief Generates c++ code for combinatorical factor insertions inside GenericSum.
@param combinatorialFactors List of integers.
@returns String c++ code for combinatorical factor insertions inside GenericSum.";
`cxx`insertFactors[combinatorialFactors:`type`classCombinatoricalFactors] :=
   StringRiffle["boost::mpl::int_<"<>ToString@#<>">"&/@combinatorialFactors,",\n"];
`cxx`insertFactors // Utils`MakeUnknownInputDefinition;
`cxx`insertFactors ~ SetAttributes ~ {Locked,Protected};

`cxx`insertColours::usage =
"@brief Generates c++ code for colour factor insertions inside GenericSum.
@param colourFactors list of numbers.
@returns String c++ code for colour factor insertions inside GenericSum.";
`cxx`insertColours[colourFactors:{__?NumberQ}] :=
Module[
   {
      ReRatioColourFactors = {Numerator@#,Denominator@#} &/@ Re@colourFactors,
      ImRatioColourFactors = {Numerator@#,Denominator@#} &/@ Im@colourFactors
   },
   StringRiffle[
      StringReplace[
         MapThread[
            "detail::complex_helper<"<>
            "detail::ratio_helper<"<>ToString@#1<>">,"<>
            "detail::ratio_helper<"<>ToString@#2 <> ">>"&,
            {ReRatioColourFactors, ImRatioColourFactors}],
         {"{" -> "", "}" -> ""}],
   ",\n"]
];
`cxx`insertColours // Utils`MakeUnknownInputDefinition;
`cxx`insertColours ~ SetAttributes ~ {Locked,Protected};

(*auxiliary functions with names of newer Mathematica versions*)
If[TrueQ[$VersionNumber<10],
StringTemplate::usage=
"This is not a full replacement of Mathematica's StringTemplate.
It works correctly only for string, containing `i` insertions with i>0";
StringTemplate::errFailed=
"Failed for this input string
`1`";
StringTemplate[str_String] :=
Module[
   {
      args = DeleteDuplicates@StringCases[str,
         HoldPattern["`"~~DigitCharacter..~~"`"]],
      noControlStrs = DeleteDuplicates@StringSplit[str,
         "`"~~DigitCharacter~~"`"],
      argRules,noControlRules,preControl,return
   },
   argRules = Rule[#,"<>ToString@#"<>StringDrop[StringDrop[#,1],-1]<>"<>"] &/@
      args;
   noControlRules = Rule[#,"\""<>#<>"\""] &/@ noControlStrs;
   preControl = StringReplace[StringReplace[StringReplace[str,
      argRules], noControlRules],"<><>"->"<>"];
   If[StringTake[str,1] === "`",preControl = StringDrop[preControl,2]];
   If[StringTake[str,-1] === "`",preControl = StringDrop[preControl,-2]];
   return=ToExpression[preControl <> "&"];
   If[return===$Failed,
      Utils`AssertOrQuit[False,StringTemplate::errFailed,str],
      return]
];
StringTemplate[___] :=
   Utils`AssertOrQuit[False,StringTemplate::usage];

SetAttributes[{StringTemplate},{Protected, Locked}]
];
If[TrueQ[$VersionNumber<10.1],
StringRiffle::usage=
"This is not a full replacement of Mathematica's StringRiffle.
It works only for [{___String},_String] input.";
StringRiffle::err="`1`";
StringRiffle[strs:{___String},sep_String] :=
   StringJoin@Riffle[strs,sep];
StringRiffle[strs:{___String},{in_String,sep_String,fin_String}] :=
   in<>StringJoin@Riffle[strs,sep]<>fin;
StringRiffle[x___] :=
   Utils`AssertOrQuit[False,StringRiffle::err,{x}];

SetAttributes[{StringRiffle},{Protected, Locked}]
];

End[];
$ContextPath = NPointFunctions`internal`contextPath;
Clear[NPointFunctions`internal`contextPath];
EndPackage[];
